<!DOCTYPE html>
<html>
  <head>
    <title>My experiment</title>
    <script type="text/javascript" src="lib/vendors/jspsych-7.0.0/jspsych.js"></script>
    <script type="text/javascript" src="lib/vendors/jspsych-6.0.0/plugins/jspsych-html-keyboard-response.js"></script>
    <script type="text/javascript" src="lib/vendors/jspsych-6.0.0/plugins/jspsych-image-keyboard-response.js"></script>
    <script type="text/javascript" src="lib/vendors/jspsych-6.0.0/plugins/jspsych-html-button-response.js"></script>
    <script type="text/javascript" src="lib/vendors/jspsych-6.0.0/plugins/jspsych-survey-html-form.js"></script>
    <script type="text/javascript" src="lib/vendors/jspsych-6.0.0/plugins/jspsych-survey-multi-select.js"></script>
    <script type="text/javascript" src="lib/vendors/jspsych-6.0.0/plugins/jspsych-preload.js"></script>
        <script type="text/javascript" src="lib/vendors/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="lib/jspsych-pavlovia-3.0.0.js"></script>
    <link rel="stylesheet" type="text/css" href="lib/vendors/jspsych-6.0.0/css/jspsych.css"/>
  </head>
  <style>
    @font-face {
      font-family: "BACS";
      src: url('BACS1.otf') format('opentype');
    };
  </style>
  <body></body>
  <script>
    var timeline = []; 

    var preload = {
      type: jsPsychPreload,
      images: ['esempio.png']
    };
    timeline.push(preload);

    var jsPsych = initJsPsych({
      on_finish: function() {
        jsPsych.data.displayData(); /* when all trials finished, display data */
      }
    });

    var pavlovia_init = {
      type: "pavlovia",
      command: "init"
    };
    timeline.push(pavlovia_init);

    function changeTextColor(color) {
      var body = document.getElementsByTagName("body")[0];
      body.style.color = color;
    };

    changeTextColor("white");

    /* WORD_GENERATION SCRIPT */
    function import_morphemes() {
      const L1affixes_list = ['JQA', 'LcO', 'Ald', 'mkc', 'Nac', 'kbu', 'aQr', 'rAm', 'YbN', 'GUa', 'Ymb', 'kam', 'uvJ', 'kYL', 'ark', 'YkZ', 'YLU', 'cbm', 'lLG', 'bLd', 'cUN', 'vcb', 'uUY', 'mZb', 'dUr', 'QGb', 'vJQ', 'Qru', 'rGl', 'Glu', 'rba', 'mLJ', 'LaA', 'Arv', 'uda', 'mvG', 'lvk', 'UZu', 'UbG', 'Jud', 'OcN', 'JUG', 'lGc', 'kmU', 'JcL', 'NUZ', 'YNu', 'JZr', 'uZc', 'rab', 'Zckv', 'ravu', 'uOAO', 'OcZJ', 'JUNa', 'rNlZ', 'NYZu', 'dYAJ', 'YUYa', 'kdrO', 'ZvkL', 'OJlN', 'YaOk', 'kGua', 'vUdm', 'Grub', 'Grbk', 'UdvY', 'QONk', 'kuvb', 'OJNk', 'crdY', 'ukbY', 'LYGA', 'NmAG', 'rAJu', 'YZUZ', 'Yaum', 'ZAUu', 'AZbl', 'Avdk', 'rZYd', 'GUOA', 'OQAr', 'GQYQ', 'uUmb', 'YZJO', 'LUOk', 'vAvb', 'dmkv', 'badk', 'QvlZ', 'rkra', 'cYUv', 'JcUk', 'LkNc', 'kJdr', 'YArG', 'AOUl', 'rULv'];
      const L1stems_list = ['ukcY', 'bYuQ', 'adkr', 'bvkr', 'mrOd', 'Udbd', 'bvuZ', 'rkYL', 'rckO', 'rvAJ', 'YQbc', 'Yadr', 'YJkb', 'kNua', 'mdla', 'ldAa', 'amJm', 'LGkA', 'aONd', 'krGu', 'UvOG', 'OZkb', 'NaJb', 'vQdO', 'alJY', 'vclY', 'JvaA', 'LQur', 'ArQu', 'rLaZ', 'GZJY', 'vAar', 'JAaG', 'JauQ', 'krUQ', 'kZUb', 'Gabk', 'uauO', 'vYLU', 'rkJu', 'kulZ', 'udkm', 'cAZu', 'YZJm', 'OkGY', 'UmNJ', 'uAkr', 'YOZN', 'AlNU', 'JNka', 'rLkm', 'LdQv', 'AlUY', 'mbZl', 'bmbN', 'rvUb', 'lkAk', 'bGuO', 'lZcu', 'uvaU', 'aUZA', 'Ydud', 'UrOQ', 'AJLr', 'lrZG', 'vblr', 'aYQm', 'dkLl', 'GAcY', 'NvYJ', 'ALGZ', 'NQZv', 'JdGm', 'kGlU', 'NkUA', 'UaYL', 'GJZm', 'dNZA', 'vJab', 'GQrc', 'JmNk', 'UJkG', 'LuaU', 'lmbY', 'UJmr', 'aYaN', 'ZdlO', 'JrGv', 'ukYZ', 'mcOJ', 'muYN', 'NJZl', 'Abka', 'OJGQ', 'Nulk', 'lGZv', 'dJNr', 'lcOc', 'YcdO', 'LuNZ', 'uQuZc', 'GLYrA', 'YuaNd', 'QcQAJ', 'YOaAb', 'UYZlZ', 'vuJZu', 'JAdLm', 'NaAQd', 'UAcdu', 'UdlGQ', 'Amacl', 'NLQGm', 'ZcGdN', 'UdYUQ', 'laYmr', 'auYAk', 'YUNkZ', 'OAblc', 'OLJbl', 'Udumd', 'LckGN', 'ALOrl', 'AmQOY', 'kabJb', 'ZYcQU', 'GumLl', 'kGamN', 'NAacQ', 'kbmZO', 'aOLZU', 'OYuvb', 'lYrua', 'Zvalv', 'Qclad', 'GNAca', 'adYrc', 'LvuOG', 'mZUrQ', 'cuOJb', 'mkmJN', 'YNrAm', 'GJGcZ', 'rbYbu', 'QbkAc', 'dvNvA', 'Juaml', 'rvOvU', 'kLvdN', 'NbmQU', 'rdLJa', 'OAmGr', 'advYO', 'vkYGl', 'uQkrd', 'mLdkZ', 'bNdmG', 'ObZbA', 'QOLmu', 'dmZvm', 'ZNLOv', 'AlQaQ', 'bYGOZ', 'vAuNl', 'LNUrJ', 'QLrOJ', 'ubALm', 'UaZma', 'kdaAJ', 'LcNUJ', 'ZdNmU', 'bdUNu', 'ckLAL', 'NvuGr', 'NbacA', 'YJLcA', 'aNYmb', 'rcmuv', 'vmuLl', 'ZkGmY', 'YLQmG', 'dGLAl', 'aLNlk', 'ObOQl', 'AZlLN', 'mUOcO', 'Ldrbv', 'damYb', 'AZaJc', 'LOLkU', 'ckduA', 'OQarQ', 'ZJLmr', 'rGUAY', 'GLluA', 'OdlNm', 'LAclA', 'JmvmO', 'JZOAk', 'JdOAY'];
      const L2affixes_list = ['TAm', 'YcM', 'tAY', 'OMC', 'DKP', 'mAM', 'DOk', 'mhc', 'YBO', 'ATc', 'PTl', 'Cdt', 'lRE', 'BCD', 'cDR', 'Akd', 'EcR', 'RDM', 'cPK', 'PMd', 'Tmc', 'tcB', 'ABb', 'OYK', 'Dmh', 'mCd', 'OBT', 'PED', 'dPc', 'OPE', 'TRK', 'tRb', 'dRA', 'YDE', 'bRC', 'Yht', 'OtM', 'APT', 'EAO', 'bTE', 'CEM', 'kBD', 'dBC', 'BbM', 'KmE', 'kPM', 'kKE', 'hBK', 'Tbk', 'MAB', 'TRkY', 'MCkm', 'AdYl', 'RCdc', 'CmYA', 'KlkD', 'dmRb', 'YKPB', 'dTAh', 'dEPD', 'KEdl', 'EKBO', 'EPBT', 'CPMl', 'YTOM', 'OdOP', 'KOYC', 'dCKc', 'RYlD', 'cthB', 'bAMO', 'BCAd', 'CMdP', 'APEM', 'AlKD', 'lMck', 'BYhT', 'RdCc', 'mtKP', 'cMRl', 'MKmY', 'khMD', 'YbBT', 'bdtK', 'TmTm', 'kDOm', 'kMEC', 'DlDT', 'CKOb', 'BRDh', 'PMYm', 'TPOM', 'DbMR', 'hRKm', 'DOAK', 'hEct', 'mKcD', 'PEdK', 'Ckbd', 'YDTk'];
      const L2stems_list = ['hbmA', 'bROC', 'OCmk', 'kKRC', 'KdAR', 'BbOD', 'DhCP', 'AdDb', 'TdTD', 'TdmA', 'EMYK', 'AbKD', 'RhPm', 'OdYP', 'DCmh', 'KElB', 'BPAl', 'hkRK', 'KDPA', 'TEBK', 'mARM', 'dKRD', 'AMkC', 'mdkK', 'tdDd', 'Ctmb', 'CYPc', 'DBkl', 'PYkC', 'tRdM', 'kPOt', 'hTDd', 'YObA', 'Ehbt', 'RCcE', 'ctkt', 'TklD', 'hChY', 'chAh', 'COTK', 'mBYl', 'lBlE', 'EhRm', 'TDKh', 'CmcO', 'TKDk', 'dYdA', 'tmYh', 'BEPO', 'OtlR', 'McMD', 'khmh', 'OEPk', 'lRCB', 'YmBd', 'ORbk', 'mBbK', 'OcYM', 'AlTd', 'DhMt', 'lTmO', 'EdBb', 'DlDd', 'ACcO', 'bAdk', 'RtRh', 'KMOc', 'DBlh', 'bcOR', 'MhKd', 'kcOY', 'blMk', 'MBmE', 'OMlT', 'mhtc', 'tmAK', 'MDKP', 'PlEK', 'kCRm', 'Ddck', 'tRPD', 'RKYk', 'hbkd', 'MTdY', 'PdDT', 'bcbM', 'PcBT', 'DMRP', 'TPCb', 'YlYc', 'Mlth', 'ktBd', 'PEtE', 'YKRk', 'hCkt', 'hlkT', 'lBKt', 'BECk', 'KABA', 'dRht', 'kKEdM', 'dClOC', 'DmAME', 'EltMB', 'KRARm', 'tKDmh', 'PCMPK', 'kcCRt', 'EPMDk', 'htmhC', 'KAERM', 'DOchl', 'EtMDM', 'DRPkY', 'BKDRY', 'EPERd', 'bmdAB', 'CDEmY', 'lhCTC', 'hYDmt', 'PMPtk', 'BOCRM', 'kcdOt', 'TObCO', 'OAmAd', 'lbBDE', 'hAROK', 'hlbtb', 'hmKPM', 'DcPTc', 'btlck', 'kDRKc', 'cdKBY', 'BMEMA', 'dTmED', 'TAdhM', 'KMDYt', 'ECtbD', 'KBKBE', 'bRABt', 'RkmdC', 'AYkEh', 'lAOKM', 'MkmEd', 'Blmcl', 'chEDO', 'dRbDb', 'kdEdY', 'PctRC', 'dMThk', 'BOckP', 'hTtBb', 'lKdbc', 'hlctE', 'ODBDA', 'COtBD', 'YlCPB', 'DkTCP', 'EYtYR', 'kRCkO', 'cBROB', 'dCtMA', 'thbOM', 'TbKME', 'ckdAm', 'OmtlD', 'cDOEB', 'KTDTB', 'CkBOP', 'RdPtD', 'PDPhl', 'dKDth', 'cRElD', 'lRckA', 'cROMt', 'PCPDh', 'BATOc', 'Phktk', 'PEkhA', 'dMYBP', 'Cchtd', 'DBPhc', 'tcYbd', 'MBKRE', 'BdtAC', 'hBmMC', 'RYtkc', 'DOBhY', 'RlAKc', 'mBmlA', 'kPkRA', 'tDPRk', 'dOYml', 'kMbTR', 'ABPRB', 'tmtEM', 'lCbcm', 'EMbDP', 'CRdBd', 'TCbDC'];
      return [L1affixes_list, L1stems_list, L2affixes_list, L2stems_list]
    };

    function cycle_through(L1affixes_list, L1stems_list, L2affixes_list, L2stems_list) {
      const testingaffix_indices = [0,1,2,3,4,1,2,3,4,0];
    
      function wordcycle(affixes,stems) {
        var reps = 0;
        var words_list = [];
        var listlength = words_list.length;
        while (listlength < 50) {
          var words_list = [];
          var congruenttesting_list = [];
          var words_dict = {};
          var congruenttesting_dict = {};
          var training_dict = {};
          var affix_subset = jsPsych.randomization.sampleWithoutReplacement(affixes, 5);
          var stem_subset = jsPsych.randomization.sampleWithoutReplacement(stems, 10);
          reps++; /* increase by 1 */ 
          console.log('Finished rep ' + reps + ' of generating word list.')
          for (let i = 0; i < stem_subset.length; i++) {
            var j = 0;
            while (j < affix_subset.length) {
              var stem = stem_subset[i];
              var last = stem.slice(-1); //
              var affix = affix_subset[j];
              if (stem != affix && last != affix[0]) {
                words_list.push([stem + affix]); /* append */ 
                var parts = [stem, affix];
                var word = stem + affix;
                var dictkeys = Object.keys(words_dict);
                if (dictkeys.includes(word) == false) {
                  words_dict[word] = parts
                };
              };
              j++;
            };
            var indice = testingaffix_indices[i];
            var affix = affix_subset[indice];
            var stem = stem_subset[i];
            var word = stem + affix;
            if (congruenttesting_list.includes(word) == false) {
              congruenttesting_list.push([stem + affix]);
              var parts = [stem, affix];
              var word = stem + affix;
              congruenttesting_dict[word] = parts
            };
          };
          var words_list = Object.keys(words_dict);
          var listlength = words_list.length;
          if (listlength < 50) {
            var affix_subset = [];
            var stem_subset = [];
            var words_list = [];
            var congruenttesting_list = [];
            var words_dict = {};
            var congruenttesting_dict = {};
            var training_dict = {}
          };
        };
        if (words_list.length == 50) {
          console.log('Finished testing word list.');
          congruenttesting_list2 = [...congruenttesting_list];
          var congruenttesting_list = [];
          var training_dict = Object.assign({}, words_dict);
          var training_list = Object.keys(training_dict);
          for (word of congruenttesting_list2) {
            var word = word.toString();
            congruenttesting_list.push(word)
          };
          for (let i = 0; i < congruenttesting_list.length; i++) {
            var word = congruenttesting_list[i];
            var training_list = Object.keys(training_dict);
            if (training_list.includes(word)) {
              delete training_dict[word];
            };
          };
          var training_list = Object.keys(training_dict);
        };
        return [affix_subset, stem_subset, words_dict, words_list, training_dict, training_list, congruenttesting_dict, congruenttesting_list]
      };

      function cross_language_testing(L1affixsubset_list, L1stemsubset_list, L2affixsubset_list, L2stemsubset_list) {
        const testingaffix_indices = [0,1,2,3,4,1,2,3,4,0];
        incongruenttesting_list = [];
        incongruenttesting_dict = {};
        for (let i = 0; i < L1stemsubset_list.length; i++) {
          var indice = testingaffix_indices[i];
          var affix = L1affixsubset_list[indice];
          var stem = L2stemsubset_list[i];
          var word = stem + affix;
          if (stem[-1] != affix[0] && incongruenttesting_list.includes(word) == false) {
            incongruenttesting_list.push([stem + affix]);
            var word = stem + affix;
            incongruenttesting_dict[word] = parts
          };
        };
        for (let j = 0; j < L2stemsubset_list.length; j++) {
          var indice = testingaffix_indices[j];
          var affix = L2affixsubset_list[indice];
          var stem = L1stemsubset_list[j];
          var word = stem + affix;
          if (stem[-1] != affix[0] && incongruenttesting_list.includes(word) == false) {
            incongruenttesting_list.push([stem + affix]);
            var parts = [stem, affix];
            var word = stem + affix;
            incongruenttesting_dict[word] = parts
          };
        };
        return [incongruenttesting_list, incongruenttesting_dict]
      };
    
      /* generate word lists for both languages */
      var incongruenttesting_list = [];
      while (incongruenttesting_list.length < 20) {
        var values = wordcycle(L1affixes_list, L1stems_list);
        var L1affixsubset_list = values[0];
        var L1stemsubset_list = values[1];
        var L1words_dict = values[2];
        var L1words_list = values[3];
        var L1training_dict = values[4];
        var L1training_list = values[5];
        var L1congruenttesting_dict = values[6];
        var L1congruenttesting_list = values[7];
        var values2 = wordcycle(L2affixes_list, L2stems_list);
        var L2affixsubset_list = values2[0];
        var L2stemsubset_list = values2[1];
        var L2words_dict = values2[2];
        var L2words_list = values2[3];
        var L2training_dict = values2[4];
        var L2training_list = values2[5];
        var L2congruenttesting_dict = values2[6];
        var L2congruenttesting_list = values2[7];
        var training_list = L1training_list.concat(L2training_list);
        var training_dict = Object.assign({},L1training_dict,L2training_dict);
        var congruenttesting_list = L1congruenttesting_list.concat(L2congruenttesting_list);
        var congruenttesting_dict = Object.assign({},L1congruenttesting_dict,L2congruenttesting_dict);
        var values3 = cross_language_testing(L1affixsubset_list, L1stemsubset_list, L2affixsubset_list, L2stemsubset_list);
        var incongruenttesting_list = values3[0];
        var incongruenttesting_dict = values3[1];
        for (let i = 0; i < incongruenttesting_list.length; i++) {
          var word = congruenttesting_list[i];
          var training_list = Object.keys(training_dict);
          if (training_list.includes(word)) {
            delete training_dict[word];
          };
        };
        var training_list = Object.keys(training_dict);
        
      };
      var all_morphemes = Object.values(training_dict);
      var all_morphemes = all_morphemes.flat();
      var all_morphemes = [...new Set(all_morphemes)];
      all_morphemes.sort((a, b) => a.length - b.length);
      var exp_threes = [];
      var exp_fours = [];
      var exp_fives = [];
      for (morpheme of all_morphemes) {
        if (morpheme.length == 3) {
          exp_threes.push(morpheme)
        };
        if (morpheme.length == 4) {
          exp_fours.push(morpheme)
        };
        if (morpheme.length == 5) {
          exp_fives.push(morpheme)
        };
      };
      var big_threes = [];
      var big_fours = [];
      var big_fives = [];
      for (morpheme of L1affixes_list) {
        if (morpheme.length == 3 && all_morphemes.includes(morpheme) == false) {
          big_threes.push(morpheme)
        };
        if (morpheme.length == 4 && all_morphemes.includes(morpheme) == false) {
          big_fours.push(morpheme)
        };
      };
      for (morpheme of L1stems_list) {
        if (morpheme.length == 4 && all_morphemes.includes(morpheme) == false) {
          big_fours.push(morpheme)
        };
        if (morpheme.length == 5 && all_morphemes.includes(morpheme) == false) {
          big_fives.push(morpheme)
        };
      };
      for (morpheme of L2affixes_list) {
        if (morpheme.length == 3 && all_morphemes.includes(morpheme) == false) {
          big_threes.push(morpheme)
        };
        if (morpheme.length == 4 && all_morphemes.includes(morpheme) == false) {
          big_fours.push(morpheme)
        };
      };
      for (morpheme of L2stems_list) {
        if (morpheme.length == 4 && all_morphemes.includes(morpheme) == false) {
          big_fours.push(morpheme)
        };
        if (morpheme.length == 5 && all_morphemes.includes(morpheme) == false) {
          big_fives.push(morpheme)
        };
      };
      var all_confounds = [];
      var confound_threes = [];
      var confound_fours = [];
      var confound_fives = [];
      confound_threes = jsPsych.randomization.sampleWithoutReplacement(big_threes, parseInt(exp_threes.length));
      confound_fours = jsPsych.randomization.sampleWithoutReplacement(big_fours, parseInt(exp_fours.length));
      confound_fives = jsPsych.randomization.sampleWithoutReplacement(big_fives, parseInt(exp_fives.length));
      var all_confounds = confound_threes.concat(confound_fours, confound_fives);
      if (all_confounds.length == all_morphemes.length && confound_threes.length == exp_threes.length && confound_fours.length == exp_fours.length && confound_fives.length == exp_fives.length) {
        console.log("Correctly generated familiarity confound set.")
      };
      var familiarity_pairs = [];
      for (let i = 0; i < 30; i++) {
        familiarity_pairs.push([all_morphemes[i], all_confounds[i]])
      };
      return [L1affixsubset_list, L1stemsubset_list, L2affixsubset_list, L2stemsubset_list, L1words_dict, L1words_list, L1training_dict, L1training_list, L1congruenttesting_dict, L1congruenttesting_list, L2words_dict, L2words_list, L2training_dict, L2training_list, L2congruenttesting_dict, L2congruenttesting_list, training_list, training_dict, congruenttesting_list, congruenttesting_dict, incongruenttesting_list, incongruenttesting_dict, familiarity_pairs]
    };

    var values4 = import_morphemes();
    var L1affixes_list = values4[0];
    var L1stems_list = values4[1];
    var L2affixes_list = values4[2];
    var L2stems_list = values4[3];
    var values5 = cycle_through(L1affixes_list, L1stems_list, L2affixes_list, L2stems_list);
    var L1affixsubset_list = values5[0];
    var L1stemsubset_list = values5[1];
    var L2affixsubset_list = values5[2];
    var L2stemsubset_list = values5[3];
    var L1words_dict = values5[4];
    var L1words_list = values5[5];
    var L1training_dict = values5[6];
    var L1training_list = values5[7];
    var L1congruenttesting_dict = values5[8];
    var L1congruenttesting_list = values5[9];
    var L2words_dict = values5[10];
    var L2words_list = values5[11];
    var L2training_dict = values5[12];
    var L2training_list = values5[13];
    var L2congruenttesting_dict = values5[14];
    var L2congruenttesting_list = values5[15];
    var training_list = values5[16];
    var training_dict = values5[17];
    var congruenttesting_list2 = values5[18];
    var congruenttesting_dict = values5[19];
    var incongruenttesting_list2 = values5[20];
    var incongruenttesting_dict = values5[21];
    var familiarity_pairs = values5[22];
    var incongruenttesting_list = [];
    for (word of incongruenttesting_list2) {
      var word = word.toString();
      incongruenttesting_list.push(word)
    };
    var congruenttesting_list = [];
    var congruenttesting = [];
    var incongruenttesting = [];
    for (word of congruenttesting_list2) {
      var word = word.toString();
      congruenttesting_list.push(word)
    };
    for (word of congruenttesting_list) {
      congruenttesting.push([word,0])
    };
    for (word of incongruenttesting_list) {
      incongruenttesting.push([word,1])
    };
    var testing = congruenttesting.concat(incongruenttesting);
    if (training_list.length == 80 && testing.length == 40) {
      console.log('Correctly generated complete stimuli set.')
    };

    console.log('Training list: ' + training_list);
    console.log(testing);

    /* JSPSYCH EXPERIMENT SCRIPT */ 
    document.body.style.backgroundColor = "#808080";

    function training_randomisation(training_list) {
      var listlength = training_list.length;
      var rand_lst = ['efjnpqsz'];
      var rep = 0;
      while (rand_lst.length < (listlength + 1)) {
        if (rep < 500) {
          var word = jsPsych.randomization.sampleWithoutReplacement(training_list, 1)[0];
          var last2_word = word.slice(-2);
          var last_training = rand_lst.slice(-1)[0];
          var last2_training = last_training.slice(-2);
          var first2_word = word.slice(0, 2);
          var first2_training = last_training.slice(0, 2);
          if (first2_word != first2_training && last2_word != last2_training && rand_lst.includes(word) == false) {
            rand_lst.push(word)
          };
          rep++;
        };
        if (rep >= 500) {
          var rand_lst = ['efjnpqsz'];
          var rep = 0
        }
      };
      rand_lst.shift();
      var rand_lst = rand_lst.flat();
      return rand_lst
    };
    
    function testing_randomisation(testing) {
      var listlength = testing.length;
      var rand_lst = [['efjnpqsz',0]];
      var rep = 0;
      while (rand_lst.length < (listlength+1)) {
        if (rep < 500) {
          var item = jsPsych.randomization.sampleWithoutReplacement(testing, 1)[0];
          var word = item[0];
          var word_condition = item[1];
          var last_item = rand_lst.slice(-1)[0];
          var last_word = last_item.slice(0)[0];
          var first2_word = word.slice(0, 2);
          var first2_last_word = last_word.slice(0, 2);
          var last2_word = word.slice(-2);
          var last2_last_word = last_word.slice(-2);
          if (first2_word != first2_last_word && last2_word != last2_last_word && rand_lst.includes(item) == false) {
            rand_lst.push(item)
          };
          rep++
        };
        if (rep >= 500) {
          var rand_lst = [['efjnpqsz',0]];
          var rep = 0;
        }
      };
      rand_lst.shift();
      return rand_lst
    };

    function FisherYatesShuffle(array) {
      var m = array.length, t, i;
      while (m) {
        i = Math.floor(Math.random() * m--);
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }
    return array;
    };

    var trainingn = 3;
    var rand_training1 = training_randomisation(training_list);
    var rand_training2 = training_randomisation(training_list);
    var rand_training3 = training_randomisation(training_list);
    var rand_testing = testing_randomisation(testing);
    var familiarity_pairs = FisherYatesShuffle(familiarity_pairs);

    /* Participant ID textbox */
    var sbjIDPrompt = {
      type: jsPsychSurveyHtmlForm,
      preamble: '<p>ID Partecipante:</b></p>',
      html: '<input name="ID" type="text" required/></p>',
      button_label: "Continuare"
    };
    timeline.push(sbjIDPrompt);

    var contButton = {
      type: jsPsychHtmlButtonResponse,
      stimulus: '',
      choices: ['Continue']
    };

    var instructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p style="font-size: 15px;">Prima di cominciare, le chiediamo di leggere il modulo di consenso informato e confermare la sua volontà di partecipare all'esperimento.</p><p style="font-size: 15px;"> La preghiamo di ricordare che questo è un progetto di ricerca e che la sua partecipazione è completamente volontaria. Lei si potra' ritirare in qualunque momento, senza necessariamente dover dare alcuna spiegazione. Lo studio al quale Le si chiede di partecipare ha lo scopo di esaminare come i lettori elaborno le parole scritte. La somministrazione delle prove è individuale. Lei sarà impegnato in una sessione di lavoro della durata media di 10 minuti, e un questionario di 10 minuti. L’ordine delle prove ed il loro svolgimento sono stabiliti in modo tale da evitare un eventuale affaticamento. Tutte le prove saranno precedute da un breve addestramento in modo tale che abbia la possibilità di familiarizzare con il compito. Sono previste alcune pause nel corso dello svolgimento dell’esperimento. Nonostante il testing preveda delle prove cognitive, il presente esperimento non costituisce una prova clinica che permetta la diagnosi di eventuali patologie.</p><p style="font-size: 15px;"> Tutti i dati raccolti grazie alla partecipazione Sua e di altre persone volontarie saranno custoditi in server sicuri e protetti da password, e non sarà consentito ad alcuna persona non autorizzata di accedervi. Le Sue informazioni personali saranno conservate separatamente dai risultati della presente ricerca, cui saranno associati soltanto attraverso un ID arbitrario. Grazie a questo processo di anonimizzazione dei dati, a nessun ricercatore sarà possibile analizzare i risultati sapendo da quale specifico partecipante essi provengono. Inoltre, questa procedura renderà impossibile la Sua identificazione anche nel momento in cui i risultati della ricerca fossero pubblicati su riviste scientifiche, o presentati a congressi o in qualsiasi altro pubblico consesso. Più in generale, i dati raccolti saranno trattati in accordo con le leggi sulla privacy e in conformità al Decreto Legislativo 30 giugno 2003 n. 196 “Codice in materia di protezione dei dati personali”.</p><p style="font-size: 15px;"> Prima di esprimere il suo consenso alla partecipazione, Le ricordiamo ancora che in caso Lei abbia bisogno di delucidazioni su qualunque aspetto della procedura sperimentale, il ricercatore è a Sua completa disposizione (aliebelt@sissa.it, davide.crepaldi@sissa.it).</p><p style="font-size: 15px;"> Le chiediamo di premere un tasto qualsiasi per continuare al consenso.</p>`,
    };
    timeline.push(instructions);

    var consent = {
      type: jsPsychSurveyMultiSelect,
      questions: [
        {
          prompt: "Dichiaro di esprimere il mio consenso a partecipare allo studio e dichiaro:", 
          options: ["di aver letto attentamente le spiegazioni relative a questo studio e all’intera procedura sperimentale;"],
          required: true
        },
        {
          prompt: "",
          options: ["di essere stato informata/o riguardo alle finalità e agli obiettivi della ricerca in questione;"],
          required: true
        },
        {
          prompt: "", 
          options: ["di aver avuto la possibilità di porre domande a proposito di qualsiasi aspetto della procedura sperimentale e di aver ottenuto risposte soddisfacenti;"],
          required: true
        },
        {
          prompt: "", 
          options: ["di essere a conoscenza dei disagi eventualmente causati dall’esperimento;"],
          required: true
        },
        {
          prompt: "", 
          options: ["di aver ricevuto soddisfacenti assicurazioni sulla riservatezza delle informazioni ottenute dall’esame della propria persona;"],
          required: true
        },
        {
          prompt: "", 
          options: ["di essere consapevole di potersi ritirare in qualsiasi fase dello studio."],
          required: true
        },
      ],
      button_label: "Continuare"
    };
    timeline.push(consent);

    var welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p>Buenvenuto all'esperimento.</p><p> In questa prima parte, vedrai delle parole prese da una lingua inventata. Le parole saranno scrite in un alfabeto nuovo. Facciamo finta che questa lingua sia una lingua parlata dagli alieni.</p><p> Vorremmo chiederle di guardare queste parole aliene. Nella parte successiva, testeremo se ha prestato attenzione a queste parole.</p><p> Per favore, chiama lo sperimentatore se ha qualche domanda.</p><p> Premi un tasto qualsiasi per vedere un esempio.</p>`,
    };
    timeline.push(welcome);

    var example = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: "<p>Ecco un esempio di cosa vedrai durante questa parte dell'esperimento:</p><img src='esempio.png' height='400px'><p>Quando sei pronti per iniziare, premi un tasto qualsiasi.</p></div",
    };
    timeline.push(example);

    /* TRAINING */
    var training_stimuli1 = [];
    for (let i = 0; i < rand_training1.length; i++) {
      var item = rand_training1[i];
      var java = '<p style="font-size: 60px; font-family: BACS">'+item+'</p>';
      var training_stimuli_dict1 = {stimulus: java, correct_response: ''};
      training_stimuli1.push(training_stimuli_dict1)
    };
    
    var training_trial1 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: jsPsych.timelineVariable('stimulus'),
      choices: 'NO_KEYS',
      stimulus_duration: 800,
      trial_duration: 1000,
      response_ends_trial: false
    };

    var training_procedure1 = {
      timeline: [training_trial1],
      timeline_variables: training_stimuli1,
    };
    timeline.push(training_procedure1);

    var inter_training1 = {
          type: jsPsychHtmlKeyboardResponse,
          stimulus: `<p>Hai completato la prima sezione di questa parte.</p><p> Premi un tasto qualsiasi per continuare.</p>`
        };
    timeline.push(inter_training1);
    
    var training_stimuli2 = [];
    for (let i = 0; i < rand_training2.length; i++) {
      var item = rand_training2[i];
      var java = '<p style="font-size: 60px; font-family: BACS">'+item+'</p>';
      var training_stimuli_dict2 = {stimulus: java, correct_response: ''};
      training_stimuli2.push(training_stimuli_dict2)
    };
    
    var training_trial2 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: jsPsych.timelineVariable('stimulus'),
      choices: 'NO_KEYS',
      stimulus_duration: 800,
      trial_duration: 1000,
      response_ends_trial: false
    };

    var training_procedure2 = {
      timeline: [training_trial2],
      timeline_variables: training_stimuli2,
    };
    timeline.push(training_procedure2);

    var inter_training2 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p>Hai completato la seconda sezione di questa parte.</p><p> Premi un tasto qualsiasi per continuare.</p>`
    };
    timeline.push(inter_training2);

    var training_stimuli3 = [];
    for (let i = 0; i < rand_training3.length; i++) {
      var item = rand_training3[i];
      var java = '<p style="font-size: 60px; font-family: BACS">'+item+'</p>';
      var training_stimuli_dict3 = {stimulus: java, correct_response: ''};
      training_stimuli3.push(training_stimuli_dict3)
    };
    
    var training_trial3 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: jsPsych.timelineVariable('stimulus'),
      choices: 'NO_KEYS',
      stimulus_duration: 800,
      trial_duration: 1000,
      response_ends_trial: false
    };

    var training_procedure3 = {
      timeline: [training_trial3],
      timeline_variables: training_stimuli3,
    };
    timeline.push(training_procedure3);

    var post_training = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p>Benissimo, hai completato la prima parte dell'esperimento.</p><p> Premi un tasto qualsiasi per continuare.</p>`
    };
    timeline.push(post_training);

    /* TESTING */
    var pre_testing = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p>Adesso vedrai altre parole, alcune delle quali appartengono alla stessa lingua aliena, mentre altre no.</p><p> C'è una differenza molto sottile tra le parole aliene e gli altri stimuli. Non preoccuparti di capire qual è questa differenza; cerca solo di intuire se ciascuna parola appartiene alla lingua aliena oppure no.</p><p> Questo compito potrebbe sembrare difficile, ma non ti preoccupare! Cerca di fare del suo meglio, e, anche se ti sembrerà di non conosciere la risposta giusta, usa semplicemente il tuo intuito e dai una risposta.</p><p> Premi <strong>'k'</strong> quando pensi che la combinazione di lettere sia una parola aliena e <strong>'d'</strong> quanda pensi che invece non lo sia. Per favore, chiama lo sperimentatore se hai qualche domanda.</p><p> Premi un tasto qualsiasi per continuare.</p>`
    };
    timeline.push(pre_testing);

    var testing_stimuli = [];
    for (let i = 0; i < rand_testing.length; i++) {
      var item = rand_testing[i];
      var condition = item[1];
      var java1 = item[0];
      if (i < 3) {
        var java2 = '<p style="font-size: 30px;">Questa parola appartiene alla lingua aliena?</p><br><p style="font-size: 60px; font-family: BACS">'+java1+'<p style="font-size: 15px">Premi <strong>k</strong> per sì, <strong>d</strong> per no.</p>'
      };
      if (i >= 3) {
        var java2 = '<p style="font-size: 30px">&emsp;</p><br><p style="font-size: 60px; font-family: BACS">'+java1+'<p style="font-size: 15px">Premi <strong>k</strong> per sì, <strong>d</strong> per no.</p>'
      };
      if (condition == 0) {
        var testing_stimuli_dict = {stimulus: java1, correct_response: 'k', java: java2}
      };
      if (condition == 1) {
        var testing_stimuli_dict = {stimulus: java1, correct_response: 'd', java: java2}
      };
      testing_stimuli.push(testing_stimuli_dict)
    };

    var testing_trial = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: jsPsych.timelineVariable('java'),
      choices: ['d', 'k'],
      data: {
        task: 'response',
        correct_response: jsPsych.timelineVariable('correct_response')
      },
      on_finish: function(data){
        data.correct = jsPsych.pluginAPI.compareKeys(data.response, data.correct_response);
      }
    };

    var testing_procedure = {
      timeline: [testing_trial],
      timeline_variables: testing_stimuli,
    };
    timeline.push(testing_procedure);

    /* FAMILIARITY TEST */
    var pre_familiarity = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p>Abbiamo quasi finito. Adesso vedrai altre parole, alcune delle quali hai già visto, mentre altre no.</p><p> Non preoccuparti di riconoscerle; cerca solo di intuire se ciascuna parola ti sembra familiare oppure no.</p><p> Questo compito potrebbe sembrare difficile, ma non ti preoccupare! Cerca di fare del tuo meglio, e, anche se ti sembrerà di non conosciere la risposta giusta, usa semplicemente il tuo intuito e dai una risposta.</p><p>Premi <strong>k</strong> quando pensi che la combinazione di lettere a destra sia una parola che ha già visto e <strong>d</strong> quanda pensi che ha già visto quella a sinistra. Per favore, chiama lo sperimentatore se hai qualche domanda.</p><p>Premi un tasto qualsiasi per continuare.</p>`
    };
    timeline.push(pre_familiarity);

    var familiarity_pairs_sides = [];
    for (let i = 0; i < familiarity_pairs.length; i++) {
      var side = Math.random() * 2 | 0;
      if (side == 0) {
        familiarity_pairs_sides.push([familiarity_pairs[i][0], familiarity_pairs[i][1], 'd'])
      };
      if (side == 1) {
        familiarity_pairs_sides.push([familiarity_pairs[i][1], familiarity_pairs[i][0], 'k'])
      }
    };

    var familiarity_stimuli = [];
    for (let i = 0; i < familiarity_pairs_sides.length; i++){
      var java1 = String(familiarity_pairs_sides[i][0]+'&emsp;&emsp;&emsp;&emsp;&emsp;'+familiarity_pairs_sides[i][1]);
      if (i < 3) {
        var java2 = '<p style="font-size: 30px;">Quale combinazione di lettere hai già visto?</p><br><p style="font-size: 60px; font-family: BACS">'+java1+'<p style="font-size: 15px">Premi <strong>d</strong> per questa combinazione di lettere&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Premi <strong>k</strong> per questa combinazione di lettere</p>'
      };
      if (i >= 3) {
        var java2 = '<p style="font-size: 30px">&emsp;</p><br><p style="font-size: 60px; font-family: BACS">'+java1+'<p style="font-size: 15px">Premi <strong>d</strong> per questa combinazione di lettere&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Premi <strong>k</strong> per questa combinazione di lettere</p>'
      };
      var familiarity_pairs_dict = {stimulus1: familiarity_pairs_sides[i][0], stimulus2: familiarity_pairs_sides[i][1], correct_response: familiarity_pairs_sides[i][2], java: java2};
      familiarity_stimuli.push(familiarity_pairs_dict)
    };

    var familiarity_trial = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: jsPsych.timelineVariable('java'),
      choices: ['d', 'k'],
      data: {
        task: 'response',
        correct_response: jsPsych.timelineVariable('correct_response')
      },
      on_finish: function(data){
        data.correct = jsPsych.pluginAPI.compareKeys(data.response, data.correct_response);
      }
    };

    var familiarity_procedure = {
      timeline: [familiarity_trial],
      timeline_variables: familiarity_stimuli,
    };
    timeline.push(familiarity_procedure);

    var goodbye = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p>Grazie per la tua partecipazione! Premi un tasto qualsiasi per uscire.</p>`
    };
    timeline.push(goodbye);

    var pavlovia_finish = {
      type: "pavlovia",
      command: "finish"
    };
    timeline.push(pavlovia_finish);

    jsPsych.run(timeline);
  </script>
</html>
