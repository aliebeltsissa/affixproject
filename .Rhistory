temp <- data.frame('sbj_ID'=rep(temp_sbj_ID,4),
'scores'=c(RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3),
'dimensions'=c('RC1_L3','RC3_L4','RC2_use_L1vsL2','RC15_hist_L3'))
data_clustering <- rbind(data_clustering,temp)
};
summary(data_clustering);
result <- density_peak_clustering(data_clustering$scores,data_clustering$sbj_ID,data_clustering$dimensions);
{
#this just checks that the scores are numbers
if (!is.numeric(scores)) stop('The score vector should be numeric');
#this arranges the input data into a dataframe, in the wide format cause that's what the function 'dist', which we'll use below, needs
temp <- data.frame(dimension=dimensions, sbjId=sbjId, score=scores);
tempWide <- reshape(temp, timevar="dimension", idvar="sbjId", direction="wide");
#this method doesn't handle well missing data, so here I substitute them with the mean for that dimension
for (j in 2:ncol(tempWide))
{
tempWide[,j][is.na(tempWide[,j])] <- rep(mean(tempWide[,j], na.rm=T), length(tempWide[,j][is.na(tempWide[,j])]));
};
#this prepares the core data frame:
density_peaks <- data.frame(subject=tempWide$sbjId, ro=rep(0,length(tempWide$sbjId)), delta=rep(0,length(tempWide$sbjId)), cluster=rep(0,length(tempWide$sbjId)));
#this computes the distance between points
distances <- as.matrix(dist(tempWide[,2:ncol(tempWide)]));
rownames(distances) <- tempWide$sbjId;
colnames(distances) <- tempWide$sbjId;
#this computes the density for each point, ro in R&L2014 terminology
temp <- ifelse(distances > threshold*median(distances, na.rm=T), 0, 1); #here we take the median of the distance distribution as a reference point, but the method should be robust with respect to this arbitrary choice
density_peaks$ro <- rowSums(temp, na.rm=T);
#this computes the distance to the closest, higher-density point
for(j in 1:nrow(density_peaks)) density_peaks$delta[j] <- min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]);
#delta is 'Inf' by definition for the highest-density point, so we change it with max(delta)
density_peaks$delta[density_peaks$ro==max(density_peaks$ro)] <- max(density_peaks$delta[density_peaks$delta!=Inf], na.rm=T);
#plot the decision plot
with(density_peaks, plot(jitter(ro,10), jitter(delta,10), type="n", axes=F, xlab='Number of relative neighbours (ro)', ylab='Minimal distance to higher density point (delta)'));
axis(1);
axis(2);
with(density_peaks, text(jitter(ro,10), jitter(delta,10), as.character(subject)));
#ask the user to identify the cluster centres
print("Pick up your cluster centres. Press ENTER when done.");
scan(what="character") ->> centres;
#assign the cluster centres their cluster ID
clusterCounter <- 1;
for (j in 1:length(centres))
{
density_peaks$cluster[density_peaks$subject==centres[j]] <- clusterCounter;
clusterCounter <- clusterCounter+1;
};
#assign all the other points their cluster ID
unassignedPoints <- which(density_peaks$cluster==0);
unassignedPoints <- unassignedPoints[order(density_peaks$ro[unassignedPoints], decreasing=T)]; #here I order the unassigned points based on their density. This eliminates the risk that points are passed through the cluster assignment algorithm when its neighbours are still all unassigned themselves.
for (j in unassignedPoints)
{
nearestHigherDensityNeighbour <- which(distances[j,] == min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]));
density_peaks[j,'cluster'] <- density_peaks[nearestHigherDensityNeighbour,'cluster'];
}
#this plots the points, color-coded by cluster, in a compressed, 2D space (via Multidimensional scaling)
temp <- cmdscale(distances, k=2);
plot(temp[,1], temp[,2], bty='n', xlab='(Multidimensional scaling)', ylab='', main='', type='n');
cluster_colors <- viridis(length(centres));
for (j in 1:length(centres)) text(temp[density_peaks$cluster==j,1], temp[density_peaks$cluster==j,2], density_peaks$subject[density_peaks$cluster==j], col=cluster_colors[j]);
# create the dataframe with delta, ro, and sbjId
result <- data.frame(cluster = density_peaks$cluster, delta = density_peaks$delta, ro = density_peaks$ro, sbjId = density_peaks$subject)
# return the result
return(result)
}
data_BLP_clustering <- subset(data_BLP, select=c(temp_sbjID,RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3));
data_clustering <- data.frame();
sbj_ID <- as.character(data_BLP_clustering$temp_sbjID);
for (x in 1:91) {
temp_sbj_ID = sbj_ID[x]
RC1_L3 = data_BLP_clustering[x,2]
RC3_L4 = data_BLP_clustering[x,3]
RC2_use_L1vsL2 = data_BLP_clustering[x,4]
RC15_hist_L3 = data_BLP_clustering[x,5]
temp <- data.frame('sbj_ID'=rep(temp_sbj_ID,4),
'scores'=c(RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3),
'dimensions'=c('RC1_L3','RC3_L4','RC2_use_L1vsL2','RC15_hist_L3'))
data_clustering <- rbind(data_clustering,temp)
};
summary(data_clustering);
result <- density_peak_clustering(data_clustering$scores,data_clustering$sbj_ID,data_clustering$dimensions);
{
#this just checks that the scores are numbers
if (!is.numeric(scores)) stop('The score vector should be numeric');
#this arranges the input data into a dataframe, in the wide format cause that's what the function 'dist', which we'll use below, needs
temp <- data.frame(dimension=dimensions, sbjId=sbjId, score=scores);
tempWide <- reshape(temp, timevar="dimension", idvar="sbjId", direction="wide");
#this method doesn't handle well missing data, so here I substitute them with the mean for that dimension
for (j in 2:ncol(tempWide))
{
tempWide[,j][is.na(tempWide[,j])] <- rep(mean(tempWide[,j], na.rm=T), length(tempWide[,j][is.na(tempWide[,j])]));
};
#this prepares the core data frame:
density_peaks <- data.frame(subject=tempWide$sbjId, ro=rep(0,length(tempWide$sbjId)), delta=rep(0,length(tempWide$sbjId)), cluster=rep(0,length(tempWide$sbjId)));
#this computes the distance between points
distances <- as.matrix(dist(tempWide[,2:ncol(tempWide)]));
rownames(distances) <- tempWide$sbjId;
colnames(distances) <- tempWide$sbjId;
#this computes the density for each point, ro in R&L2014 terminology
temp <- ifelse(distances > threshold*median(distances, na.rm=T), 0, 1); #here we take the median of the distance distribution as a reference point, but the method should be robust with respect to this arbitrary choice
density_peaks$ro <- rowSums(temp, na.rm=T);
#this computes the distance to the closest, higher-density point
for(j in 1:nrow(density_peaks)) density_peaks$delta[j] <- min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]);
#delta is 'Inf' by definition for the highest-density point, so we change it with max(delta)
density_peaks$delta[density_peaks$ro==max(density_peaks$ro)] <- max(density_peaks$delta[density_peaks$delta!=Inf], na.rm=T);
#plot the decision plot
with(density_peaks, plot(jitter(ro,4), jitter(delta,4), type="n", axes=F, xlab='Number of relative neighbours (ro)', ylab='Minimal distance to higher density point (delta)'));
axis(1);
axis(2);
with(density_peaks, text(jitter(ro,4), jitter(delta,4), as.character(subject)));
#ask the user to identify the cluster centres
print("Pick up your cluster centres. Press ENTER when done.");
scan(what="character") ->> centres;
#assign the cluster centres their cluster ID
clusterCounter <- 1;
for (j in 1:length(centres))
{
density_peaks$cluster[density_peaks$subject==centres[j]] <- clusterCounter;
clusterCounter <- clusterCounter+1;
};
#assign all the other points their cluster ID
unassignedPoints <- which(density_peaks$cluster==0);
unassignedPoints <- unassignedPoints[order(density_peaks$ro[unassignedPoints], decreasing=T)]; #here I order the unassigned points based on their density. This eliminates the risk that points are passed through the cluster assignment algorithm when its neighbours are still all unassigned themselves.
for (j in unassignedPoints)
{
nearestHigherDensityNeighbour <- which(distances[j,] == min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]));
density_peaks[j,'cluster'] <- density_peaks[nearestHigherDensityNeighbour,'cluster'];
}
#this plots the points, color-coded by cluster, in a compressed, 2D space (via Multidimensional scaling)
temp <- cmdscale(distances, k=2);
plot(temp[,1], temp[,2], bty='n', xlab='(Multidimensional scaling)', ylab='', main='', type='n');
cluster_colors <- viridis(length(centres));
for (j in 1:length(centres)) text(temp[density_peaks$cluster==j,1], temp[density_peaks$cluster==j,2], density_peaks$subject[density_peaks$cluster==j], col=cluster_colors[j]);
# create the dataframe with delta, ro, and sbjId
result <- data.frame(cluster = density_peaks$cluster, delta = density_peaks$delta, ro = density_peaks$ro, sbjId = density_peaks$subject)
# return the result
return(result)
}
data_BLP_clustering <- subset(data_BLP, select=c(temp_sbjID,RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3));
data_clustering <- data.frame();
sbj_ID <- as.character(data_BLP_clustering$temp_sbjID);
for (x in 1:91) {
temp_sbj_ID = sbj_ID[x]
RC1_L3 = data_BLP_clustering[x,2]
RC3_L4 = data_BLP_clustering[x,3]
RC2_use_L1vsL2 = data_BLP_clustering[x,4]
RC15_hist_L3 = data_BLP_clustering[x,5]
temp <- data.frame('sbj_ID'=rep(temp_sbj_ID,4),
'scores'=c(RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3),
'dimensions'=c('RC1_L3','RC3_L4','RC2_use_L1vsL2','RC15_hist_L3'))
data_clustering <- rbind(data_clustering,temp)
};
summary(data_clustering);
result <- density_peak_clustering(data_clustering$scores,data_clustering$sbj_ID,data_clustering$dimensions);
{
#this just checks that the scores are numbers
if (!is.numeric(scores)) stop('The score vector should be numeric');
#this arranges the input data into a dataframe, in the wide format cause that's what the function 'dist', which we'll use below, needs
temp <- data.frame(dimension=dimensions, sbjId=sbjId, score=scores);
tempWide <- reshape(temp, timevar="dimension", idvar="sbjId", direction="wide");
#this method doesn't handle well missing data, so here I substitute them with the mean for that dimension
for (j in 2:ncol(tempWide))
{
tempWide[,j][is.na(tempWide[,j])] <- rep(mean(tempWide[,j], na.rm=T), length(tempWide[,j][is.na(tempWide[,j])]));
};
#this prepares the core data frame:
density_peaks <- data.frame(subject=tempWide$sbjId, ro=rep(0,length(tempWide$sbjId)), delta=rep(0,length(tempWide$sbjId)), cluster=rep(0,length(tempWide$sbjId)));
#this computes the distance between points
distances <- as.matrix(dist(tempWide[,2:ncol(tempWide)]));
rownames(distances) <- tempWide$sbjId;
colnames(distances) <- tempWide$sbjId;
#this computes the density for each point, ro in R&L2014 terminology
temp <- ifelse(distances > threshold*median(distances, na.rm=T), 0, 1); #here we take the median of the distance distribution as a reference point, but the method should be robust with respect to this arbitrary choice
density_peaks$ro <- rowSums(temp, na.rm=T);
#this computes the distance to the closest, higher-density point
for(j in 1:nrow(density_peaks)) density_peaks$delta[j] <- min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]);
#delta is 'Inf' by definition for the highest-density point, so we change it with max(delta)
density_peaks$delta[density_peaks$ro==max(density_peaks$ro)] <- max(density_peaks$delta[density_peaks$delta!=Inf], na.rm=T);
#plot the decision plot
with(density_peaks, plot(jitter(ro,2), jitter(delta,2), type="n", axes=F, xlab='Number of relative neighbours (ro)', ylab='Minimal distance to higher density point (delta)'));
axis(1);
axis(2);
with(density_peaks, text(jitter(ro,2), jitter(delta,2), as.character(subject)));
#ask the user to identify the cluster centres
print("Pick up your cluster centres. Press ENTER when done.");
scan(what="character") ->> centres;
#assign the cluster centres their cluster ID
clusterCounter <- 1;
for (j in 1:length(centres))
{
density_peaks$cluster[density_peaks$subject==centres[j]] <- clusterCounter;
clusterCounter <- clusterCounter+1;
};
#assign all the other points their cluster ID
unassignedPoints <- which(density_peaks$cluster==0);
unassignedPoints <- unassignedPoints[order(density_peaks$ro[unassignedPoints], decreasing=T)]; #here I order the unassigned points based on their density. This eliminates the risk that points are passed through the cluster assignment algorithm when its neighbours are still all unassigned themselves.
for (j in unassignedPoints)
{
nearestHigherDensityNeighbour <- which(distances[j,] == min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]));
density_peaks[j,'cluster'] <- density_peaks[nearestHigherDensityNeighbour,'cluster'];
}
#this plots the points, color-coded by cluster, in a compressed, 2D space (via Multidimensional scaling)
temp <- cmdscale(distances, k=2);
plot(temp[,1], temp[,2], bty='n', xlab='(Multidimensional scaling)', ylab='', main='', type='n');
cluster_colors <- viridis(length(centres));
for (j in 1:length(centres)) text(temp[density_peaks$cluster==j,1], temp[density_peaks$cluster==j,2], density_peaks$subject[density_peaks$cluster==j], col=cluster_colors[j]);
# create the dataframe with delta, ro, and sbjId
result <- data.frame(cluster = density_peaks$cluster, delta = density_peaks$delta, ro = density_peaks$ro, sbjId = density_peaks$subject)
# return the result
return(result)
}
data_BLP_clustering <- subset(data_BLP, select=c(temp_sbjID,RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3));
data_clustering <- data.frame();
sbj_ID <- as.character(data_BLP_clustering$temp_sbjID);
for (x in 1:91) {
temp_sbj_ID = sbj_ID[x]
RC1_L3 = data_BLP_clustering[x,2]
RC3_L4 = data_BLP_clustering[x,3]
RC2_use_L1vsL2 = data_BLP_clustering[x,4]
RC15_hist_L3 = data_BLP_clustering[x,5]
temp <- data.frame('sbj_ID'=rep(temp_sbj_ID,4),
'scores'=c(RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3),
'dimensions'=c('RC1_L3','RC3_L4','RC2_use_L1vsL2','RC15_hist_L3'))
data_clustering <- rbind(data_clustering,temp)
};
summary(data_clustering);
result <- density_peak_clustering(data_clustering$scores,data_clustering$sbj_ID,data_clustering$dimensions);
{
#this just checks that the scores are numbers
if (!is.numeric(scores)) stop('The score vector should be numeric');
#this arranges the input data into a dataframe, in the wide format cause that's what the function 'dist', which we'll use below, needs
temp <- data.frame(dimension=dimensions, sbjId=sbjId, score=scores);
tempWide <- reshape(temp, timevar="dimension", idvar="sbjId", direction="wide");
#this method doesn't handle well missing data, so here I substitute them with the mean for that dimension
for (j in 2:ncol(tempWide))
{
tempWide[,j][is.na(tempWide[,j])] <- rep(mean(tempWide[,j], na.rm=T), length(tempWide[,j][is.na(tempWide[,j])]));
};
#this prepares the core data frame:
density_peaks <- data.frame(subject=tempWide$sbjId, ro=rep(0,length(tempWide$sbjId)), delta=rep(0,length(tempWide$sbjId)), cluster=rep(0,length(tempWide$sbjId)));
#this computes the distance between points
distances <- as.matrix(dist(tempWide[,2:ncol(tempWide)]));
rownames(distances) <- tempWide$sbjId;
colnames(distances) <- tempWide$sbjId;
#this computes the density for each point, ro in R&L2014 terminology
temp <- ifelse(distances > threshold*median(distances, na.rm=T), 0, 1); #here we take the median of the distance distribution as a reference point, but the method should be robust with respect to this arbitrary choice
density_peaks$ro <- rowSums(temp, na.rm=T);
#this computes the distance to the closest, higher-density point
for(j in 1:nrow(density_peaks)) density_peaks$delta[j] <- min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]);
#delta is 'Inf' by definition for the highest-density point, so we change it with max(delta)
density_peaks$delta[density_peaks$ro==max(density_peaks$ro)] <- max(density_peaks$delta[density_peaks$delta!=Inf], na.rm=T);
#plot the decision plot
with(density_peaks, plot(jitter(ro,2), jitter(delta,2), type="n", axes=F, xlab='Number of relative neighbours (ro)', ylab='Minimal distance to higher density point (delta)'));
axis(1);
axis(2);
with(density_peaks, text(jitter(ro,2), jitter(delta,2), as.character(subject)));
#ask the user to identify the cluster centres
print("Pick up your cluster centres. Press ENTER when done.");
scan(what="character") ->> centres;
#assign the cluster centres their cluster ID
clusterCounter <- 1;
for (j in 1:length(centres))
{
density_peaks$cluster[density_peaks$subject==centres[j]] <- clusterCounter;
clusterCounter <- clusterCounter+1;
};
#assign all the other points their cluster ID
unassignedPoints <- which(density_peaks$cluster==0);
unassignedPoints <- unassignedPoints[order(density_peaks$ro[unassignedPoints], decreasing=T)]; #here I order the unassigned points based on their density. This eliminates the risk that points are passed through the cluster assignment algorithm when its neighbours are still all unassigned themselves.
for (j in unassignedPoints)
{
nearestHigherDensityNeighbour <- which(distances[j,] == min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]));
density_peaks[j,'cluster'] <- density_peaks[nearestHigherDensityNeighbour,'cluster'];
}
#this plots the points, color-coded by cluster, in a compressed, 2D space (via Multidimensional scaling)
temp <- cmdscale(distances, k=2);
plot(temp[,1], temp[,2], bty='n', xlab='(Multidimensional scaling)', ylab='', main='', type='n');
cluster_colors <- viridis(length(centres));
for (j in 1:length(centres)) text(temp[density_peaks$cluster==j,1], temp[density_peaks$cluster==j,2], density_peaks$subject[density_peaks$cluster==j], col=cluster_colors[j]);
# create the dataframe with delta, ro, and sbjId
result <- data.frame(cluster = density_peaks$cluster, delta = density_peaks$delta, ro = density_peaks$ro, sbjId = density_peaks$subject)
# return the result
return(result)
}
density_peak_clustering <- function(scores,
sbjId, #these are the "objects"
dimensions, #this would be the item in a psychological experiment
threshold=.2
)
{
#this just checks that the scores are numbers
if (!is.numeric(scores)) stop('The score vector should be numeric');
#this arranges the input data into a dataframe, in the wide format cause that's what the function 'dist', which we'll use below, needs
temp <- data.frame(dimension=dimensions, sbjId=sbjId, score=scores);
tempWide <- reshape(temp, timevar="dimension", idvar="sbjId", direction="wide");
#this method doesn't handle well missing data, so here I substitute them with the mean for that dimension
for (j in 2:ncol(tempWide))
{
tempWide[,j][is.na(tempWide[,j])] <- rep(mean(tempWide[,j], na.rm=T), length(tempWide[,j][is.na(tempWide[,j])]));
};
#this prepares the core data frame:
density_peaks <- data.frame(subject=tempWide$sbjId, ro=rep(0,length(tempWide$sbjId)), delta=rep(0,length(tempWide$sbjId)), cluster=rep(0,length(tempWide$sbjId)));
#this computes the distance between points
distances <- as.matrix(dist(tempWide[,2:ncol(tempWide)]));
rownames(distances) <- tempWide$sbjId;
colnames(distances) <- tempWide$sbjId;
#this computes the density for each point, ro in R&L2014 terminology
temp <- ifelse(distances > threshold*median(distances, na.rm=T), 0, 1); #here we take the median of the distance distribution as a reference point, but the method should be robust with respect to this arbitrary choice
density_peaks$ro <- rowSums(temp, na.rm=T);
#this computes the distance to the closest, higher-density point
for(j in 1:nrow(density_peaks)) density_peaks$delta[j] <- min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]);
#delta is 'Inf' by definition for the highest-density point, so we change it with max(delta)
density_peaks$delta[density_peaks$ro==max(density_peaks$ro)] <- max(density_peaks$delta[density_peaks$delta!=Inf], na.rm=T);
#plot the decision plot
with(density_peaks, plot(jitter(ro,2), jitter(delta,2), type="n", axes=F, xlab='Number of relative neighbours (ro)', ylab='Minimal distance to higher density point (delta)'));
axis(1);
axis(2);
with(density_peaks, text(jitter(ro,2), jitter(delta,2), as.character(subject)));
#ask the user to identify the cluster centres
print("Pick up your cluster centres. Press ENTER when done.");
scan(what="character") ->> centres;
#assign the cluster centres their cluster ID
clusterCounter <- 1;
for (j in 1:length(centres))
{
density_peaks$cluster[density_peaks$subject==centres[j]] <- clusterCounter;
clusterCounter <- clusterCounter+1;
};
#assign all the other points their cluster ID
unassignedPoints <- which(density_peaks$cluster==0);
unassignedPoints <- unassignedPoints[order(density_peaks$ro[unassignedPoints], decreasing=T)]; #here I order the unassigned points based on their density. This eliminates the risk that points are passed through the cluster assignment algorithm when its neighbours are still all unassigned themselves.
for (j in unassignedPoints)
{
nearestHigherDensityNeighbour <- which(distances[j,] == min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]));
density_peaks[j,'cluster'] <- density_peaks[nearestHigherDensityNeighbour,'cluster'];
}
#this plots the points, color-coded by cluster, in a compressed, 2D space (via Multidimensional scaling)
temp <- cmdscale(distances, k=2);
plot(temp[,1], temp[,2], bty='n', xlab='(Multidimensional scaling)', ylab='', main='', type='n');
cluster_colors <- viridis(length(centres));
for (j in 1:length(centres)) text(temp[density_peaks$cluster==j,1], temp[density_peaks$cluster==j,2], density_peaks$subject[density_peaks$cluster==j], col=cluster_colors[j]);
# create the dataframe with delta, ro, and sbjId
result <- data.frame(cluster = density_peaks$cluster, delta = density_peaks$delta, ro = density_peaks$ro, sbjId = density_peaks$subject)
# return the result
return(result)
}
data_BLP_clustering <- subset(data_BLP, select=c(temp_sbjID,RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3));
data_clustering <- data.frame();
sbj_ID <- as.character(data_BLP_clustering$temp_sbjID);
for (x in 1:91) {
temp_sbj_ID = sbj_ID[x]
RC1_L3 = data_BLP_clustering[x,2]
RC3_L4 = data_BLP_clustering[x,3]
RC2_use_L1vsL2 = data_BLP_clustering[x,4]
RC15_hist_L3 = data_BLP_clustering[x,5]
temp <- data.frame('sbj_ID'=rep(temp_sbj_ID,4),
'scores'=c(RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3),
'dimensions'=c('RC1_L3','RC3_L4','RC2_use_L1vsL2','RC15_hist_L3'))
data_clustering <- rbind(data_clustering,temp)
};
summary(data_clustering);
result <- density_peak_clustering(data_clustering$scores,data_clustering$sbj_ID,data_clustering$dimensions);
density_peak_clustering <- function(scores,
sbjId, #these are the "objects"
dimensions, #this would be the item in a psychological experiment
threshold=.2
)
{
#this just checks that the scores are numbers
if (!is.numeric(scores)) stop('The score vector should be numeric');
#this arranges the input data into a dataframe, in the wide format cause that's what the function 'dist', which we'll use below, needs
temp <- data.frame(dimension=dimensions, sbjId=sbjId, score=scores);
tempWide <- reshape(temp, timevar="dimension", idvar="sbjId", direction="wide");
#this method doesn't handle well missing data, so here I substitute them with the mean for that dimension
for (j in 2:ncol(tempWide))
{
tempWide[,j][is.na(tempWide[,j])] <- rep(mean(tempWide[,j], na.rm=T), length(tempWide[,j][is.na(tempWide[,j])]));
};
#this prepares the core data frame:
density_peaks <- data.frame(subject=tempWide$sbjId, ro=rep(0,length(tempWide$sbjId)), delta=rep(0,length(tempWide$sbjId)), cluster=rep(0,length(tempWide$sbjId)));
#this computes the distance between points
distances <- as.matrix(dist(tempWide[,2:ncol(tempWide)]));
rownames(distances) <- tempWide$sbjId;
colnames(distances) <- tempWide$sbjId;
#this computes the density for each point, ro in R&L2014 terminology
temp <- ifelse(distances > threshold*median(distances, na.rm=T), 0, 1); #here we take the median of the distance distribution as a reference point, but the method should be robust with respect to this arbitrary choice
density_peaks$ro <- rowSums(temp, na.rm=T);
#this computes the distance to the closest, higher-density point
for(j in 1:nrow(density_peaks)) density_peaks$delta[j] <- min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]);
#delta is 'Inf' by definition for the highest-density point, so we change it with max(delta)
density_peaks$delta[density_peaks$ro==max(density_peaks$ro)] <- max(density_peaks$delta[density_peaks$delta!=Inf], na.rm=T);
#plot the decision plot
with(density_peaks, plot(jitter(ro,20), jitter(delta,20), type="n", axes=F, xlab='Number of relative neighbours (ro)', ylab='Minimal distance to higher density point (delta)'));
axis(1);
axis(2);
with(density_peaks, text(jitter(ro,20), jitter(delta,20), as.character(subject)));
#ask the user to identify the cluster centres
print("Pick up your cluster centres. Press ENTER when done.");
scan(what="character") ->> centres;
#assign the cluster centres their cluster ID
clusterCounter <- 1;
for (j in 1:length(centres))
{
density_peaks$cluster[density_peaks$subject==centres[j]] <- clusterCounter;
clusterCounter <- clusterCounter+1;
};
#assign all the other points their cluster ID
unassignedPoints <- which(density_peaks$cluster==0);
unassignedPoints <- unassignedPoints[order(density_peaks$ro[unassignedPoints], decreasing=T)]; #here I order the unassigned points based on their density. This eliminates the risk that points are passed through the cluster assignment algorithm when its neighbours are still all unassigned themselves.
for (j in unassignedPoints)
{
nearestHigherDensityNeighbour <- which(distances[j,] == min(distances[j,which(density_peaks$ro>density_peaks$ro[j])]));
density_peaks[j,'cluster'] <- density_peaks[nearestHigherDensityNeighbour,'cluster'];
}
#this plots the points, color-coded by cluster, in a compressed, 2D space (via Multidimensional scaling)
temp <- cmdscale(distances, k=2);
plot(temp[,1], temp[,2], bty='n', xlab='(Multidimensional scaling)', ylab='', main='', type='n');
cluster_colors <- viridis(length(centres));
for (j in 1:length(centres)) text(temp[density_peaks$cluster==j,1], temp[density_peaks$cluster==j,2], density_peaks$subject[density_peaks$cluster==j], col=cluster_colors[j]);
# create the dataframe with delta, ro, and sbjId
result <- data.frame(cluster = density_peaks$cluster, delta = density_peaks$delta, ro = density_peaks$ro, sbjId = density_peaks$subject)
# return the result
return(result)
}
data_BLP_clustering <- subset(data_BLP, select=c(temp_sbjID,RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3));
data_clustering <- data.frame();
sbj_ID <- as.character(data_BLP_clustering$temp_sbjID);
for (x in 1:91) {
temp_sbj_ID = sbj_ID[x]
RC1_L3 = data_BLP_clustering[x,2]
RC3_L4 = data_BLP_clustering[x,3]
RC2_use_L1vsL2 = data_BLP_clustering[x,4]
RC15_hist_L3 = data_BLP_clustering[x,5]
temp <- data.frame('sbj_ID'=rep(temp_sbj_ID,4),
'scores'=c(RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3),
'dimensions'=c('RC1_L3','RC3_L4','RC2_use_L1vsL2','RC15_hist_L3'))
data_clustering <- rbind(data_clustering,temp)
};
summary(data_clustering);
result <- density_peak_clustering(data_clustering$scores,data_clustering$sbj_ID,data_clustering$dimensions);
###################
# CLUSTERING TREE #
###################
library(Hmisc);
data_BLP_short <- subset(data_BLP, select=-c(sbj_ID,Age,Gender,Education,L1,L2,L3,L4,otherLs,task,AttentionL1,AttentionL2,AttentionL3,AttentionL4,temp_sbjID));
temp <- subset(data_BLP_short, select=c(HistoryL1Score,HistoryL2Score,HistoryL3Score,HistoryL4Score,UseL1Score,UseL2Score,UseL3Score,UseL4Score,ProficiencyL1Score,ProficiencyL2Score,ProficiencyL3Score,ProficiencyL4Score,AttitudeL1Score,AttitudeL2Score,AttitudeL3Score,AttitudeL4Score,L1Score,L2Score,L3Score,L4Score,lang_var,lang_ent,multi_exp,L1_L2_diff,RC1_L3,RC3_L4,RC2_use_L1vsL2,RC15_hist_L3));
plot(varclus(as.matrix(temp)));
# remove datapoints if participant doesn't know additional languages
data_BLP$langfilter1 <- TRUE;
data_BLP$langfilter2 <- TRUE;
data_BLP$langfilter3 <- TRUE;
data_BLP$langfilter4 <- TRUE;
data_BLP$langfilter2[data_BLP$L2Score==0] <- FALSE;
data_BLP$langfilter3[data_BLP$L3Score==0] <- FALSE;
data_BLP$langfilter4[data_BLP$L4Score==0] <- FALSE;
data_BLP$L2Score[data_BLP$langfilter2==FALSE] <- NA;
data_BLP$L3Score[data_BLP$langfilter3==FALSE] <- NA;
data_BLP$L4Score[data_BLP$langfilter4==FALSE] <- NA;
ok2 <- ! is.na(data_BLP$L2Score);
ok3 <- ! is.na(data_BLP$L3Score);
ok4 <- ! is.na(data_BLP$L4Score);
# plot language scores per participant
#by temp_sbjID
plot(data_BLP$L1Score~data_BLP$temp_sbjID,ylab="Language Score",ylim=c(0,230),xlab="Participant",main="",pch=19,cex.lab=1.5,col=cols2[1],xaxt="n",yaxs="i");
axis(1, at = c(1:193));
# plot language scores per participant
#by temp_sbjID
plot(data_BLP$L1Score~data_BLP$temp_sbjID,ylab="Language Score",ylim=c(0,230),xlab="Participant",main="",pch=19,cex.lab=1.5,col=cols2[1],xaxt="n",yaxs="i");
axis(1, at = c(1:91));
points(data_BLP$L2Score~data_BLP$temp_sbjID,subset=ok2,pch=19,col=cols2[2]);
points(data_BLP$L3Score~data_BLP$temp_sbjID,subset=ok2,pch=19,col=cols2[3]);
points(data_BLP$L4Score~data_BLP$temp_sbjID,subset=ok2,pch=19,col=cols2[4]);
# plot language scores per participant
cols2 <- paletteer_d("ggthemes::Classic_20");
#by temp_sbjID
plot(data_BLP$L1Score~data_BLP$temp_sbjID,ylab="Language Score",ylim=c(0,230),xlab="Participant",main="",pch=19,cex.lab=1.5,col=cols2[1],xaxt="n",yaxs="i");
axis(1, at = c(1:91));
points(data_BLP$L3Score~data_BLP$temp_sbjID,subset=ok2,pch=19,col=cols2[3]);
points(data_BLP$L2Score~data_BLP$temp_sbjID,subset=ok2,pch=19,col=cols2[2]);
points(data_BLP$L4Score~data_BLP$temp_sbjID,subset=ok2,pch=19,col=cols2[4]);
legend("bottomright",title="Language:",c("L1","L2","L3","L4"),fill=c(cols2[1],cols2[2],cols2[3],cols2[4]),bty = "n",
cex=1,y.intersp=0.5);
abline(h=218, lty=5);
#by lang_ent
sorted_order1 <- order(data_BLP$lang_ent);
plot(data_BLP$L1Score[sorted_order1]~data_BLP$temp_sbjID[sorted_order1],ylab="Language Score",ylim=c(0,230),xlab="Participants, by increasing lang_ent",main="",pch=19,cex.lab=1.5,col=cols2[1],xaxt="n",yaxs="i");
points(data_BLP$L2Score[sorted_order1]~data_BLP$temp_sbjID[sorted_order1],subset=ok2,pch=19,col=cols2[2]);
points(data_BLP$L3Score[sorted_order1]~data_BLP$temp_sbjID[sorted_order1],subset=ok2,pch=19,col=cols2[3]);
points(data_BLP$L4Score[sorted_order1]~data_BLP$temp_sbjID[sorted_order1],subset=ok2,pch=19,col=cols2[4]);
legend("bottomright",title="Language:",c("L1","L2","L3","L4"),fill=c(cols2[1],cols2[2],cols2[3],cols2[4]),bty = "n",
cex=1,y.intersp=0.5);
abline(h=218, lty=5);
#by multi_exp
sorted_order2 <- order(data_BLP$multi_exp);
plot(data_BLP$L1Score[sorted_order2]~data_BLP$temp_sbjID[sorted_order2],ylab="Language Score",ylim=c(0,230),xlab="Participants, by increasing multi_exp",main="",pch=19,cex.lab=1.5,col=cols2[1],xaxt="n",yaxs="i");
points(data_BLP$L2Score[sorted_order2]~data_BLP$temp_sbjID[sorted_order2],subset=ok2,pch=19,col=cols2[2]);
points(data_BLP$L3Score[sorted_order2]~data_BLP$temp_sbjID[sorted_order2],subset=ok2,pch=19,col=cols2[3]);
points(data_BLP$L4Score[sorted_order2]~data_BLP$temp_sbjID[sorted_order2],subset=ok2,pch=19,col=cols2[4]);
legend("bottomright",title="Language:",c("L1","L2","L3","L4"),fill=c(cols2[1],cols2[2],cols2[3],cols2[4]),bty = "n",
cex=1,y.intersp=0.5);
abline(h=218, lty=5);
#by L1_L2_diff
sorted_order3 <- order(data_BLP$L1_L2_diff);
plot(data_BLP$L1Score[sorted_order3]~data_BLP$temp_sbjID[sorted_order3],ylab="Language Score",ylim=c(0,230),xlab="Participants, by increasing L1_L2_diff",main="",pch=19,cex.lab=1.5,col=cols2[1],xaxt="n",yaxs="i");
points(data_BLP$L2Score[sorted_order3]~data_BLP$temp_sbjID[sorted_order3],subset=ok2,pch=19,col=cols2[2]);
points(data_BLP$L3Score[sorted_order3]~data_BLP$temp_sbjID[sorted_order3],subset=ok2,pch=19,col=cols2[3]);
points(data_BLP$L4Score[sorted_order3]~data_BLP$temp_sbjID[sorted_order3],subset=ok2,pch=19,col=cols2[4]);
legend("bottomright",title="Language:",c("L1","L2","L3","L4"),fill=c(cols2[1],cols2[2],cols2[3],cols2[4]),bty = "n",
cex=1,y.intersp=0.5);
abline(h=218, lty=5)
sorted_order3
View(sorted_order3)
View(data_BLP)
