<!DOCTYPE html>
<html>
  <head>
    <title>My experiment</title>
    <script src="https://unpkg.com/jspsych@7.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@1.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@1.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-multi-select@1.1.1"></script>
    <script src="jspsych/dist/jspsych-psychophysics.js"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload@1.0.0"></script>
    <link href="https://unpkg.com/jspsych@7.0.0/css/jspsych.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://unpkg.com/jspsych@7.2.3/css/jspsych.css">
  </head>
  <style>
    @font-face {
      font-family: "BACS";
      src: url('BACS1.otf') format('opentype');
    };
  </style>
  <body></body>
  <script>

    var jsPsych = initJsPsych({
      on_finish: function() {
        jsPsych.data.displayData(); /* when all trials finished, display data */
      }
    });

    function changeTextColor(color) {
      var body = document.getElementsByTagName("body")[0];
      body.style.color = color;
    };

    changeTextColor("white");

    /* WORD_GENERATION SCRIPT */
    function import_morphemes() {
      const L1affixes_list = ['JQA', 'LcO', 'Ald', 'mkc', 'Nac', 'kbu', 'aQr', 'rAm', 'YbN', 'GUa', 'Ymb', 'kam', 'uvJ', 'kYL', 'ark', 'YkZ', 'YLU', 'cbm', 'lLG', 'bLd', 'cUN', 'vcb', 'uUY', 'mZb', 'dUr', 'QGb', 'vJQ', 'Qru', 'rGl', 'Glu', 'rba', 'mLJ', 'LaA', 'Arv', 'uda', 'mvG', 'lvk', 'UZu', 'UbG', 'Jud', 'OcN', 'JUG', 'lGc', 'kmU', 'JcL', 'NUZ', 'YNu', 'JZr', 'uZc', 'rab', 'Zckv', 'ravu', 'uOAO', 'OcZJ', 'JUNa', 'rNlZ', 'NYZu', 'dYAJ', 'YUYa', 'kdrO', 'ZvkL', 'OJlN', 'YaOk', 'kGua', 'vUdm', 'Grub', 'Grbk', 'UdvY', 'QONk', 'kuvb', 'OJNk', 'crdY', 'ukbY', 'LYGA', 'NmAG', 'rAJu', 'YZUZ', 'Yaum', 'ZAUu', 'AZbl', 'Avdk', 'rZYd', 'GUOA', 'OQAr', 'GQYQ', 'uUmb', 'YZJO', 'LUOk', 'vAvb', 'dmkv', 'badk', 'QvlZ', 'rkra', 'cYUv', 'JcUk', 'LkNc', 'kJdr', 'YArG', 'AOUl', 'rULv'];
      const L1stems_list = ['ukcY', 'bYuQ', 'adkr', 'bvkr', 'mrOd', 'Udbd', 'bvuZ', 'rkYL', 'rckO', 'rvAJ', 'YQbc', 'Yadr', 'YJkb', 'kNua', 'mdla', 'ldAa', 'amJm', 'LGkA', 'aONd', 'krGu', 'UvOG', 'OZkb', 'NaJb', 'vQdO', 'alJY', 'vclY', 'JvaA', 'LQur', 'ArQu', 'rLaZ', 'GZJY', 'vAar', 'JAaG', 'JauQ', 'krUQ', 'kZUb', 'Gabk', 'uauO', 'vYLU', 'rkJu', 'kulZ', 'udkm', 'cAZu', 'YZJm', 'OkGY', 'UmNJ', 'uAkr', 'YOZN', 'AlNU', 'JNka', 'rLkm', 'LdQv', 'AlUY', 'mbZl', 'bmbN', 'rvUb', 'lkAk', 'bGuO', 'lZcu', 'uvaU', 'aUZA', 'Ydud', 'UrOQ', 'AJLr', 'lrZG', 'vblr', 'aYQm', 'dkLl', 'GAcY', 'NvYJ', 'ALGZ', 'NQZv', 'JdGm', 'kGlU', 'NkUA', 'UaYL', 'GJZm', 'dNZA', 'vJab', 'GQrc', 'JmNk', 'UJkG', 'LuaU', 'lmbY', 'UJmr', 'aYaN', 'ZdlO', 'JrGv', 'ukYZ', 'mcOJ', 'muYN', 'NJZl', 'Abka', 'OJGQ', 'Nulk', 'lGZv', 'dJNr', 'lcOc', 'YcdO', 'LuNZ', 'uQuZc', 'GLYrA', 'YuaNd', 'QcQAJ', 'YOaAb', 'UYZlZ', 'vuJZu', 'JAdLm', 'NaAQd', 'UAcdu', 'UdlGQ', 'Amacl', 'NLQGm', 'ZcGdN', 'UdYUQ', 'laYmr', 'auYAk', 'YUNkZ', 'OAblc', 'OLJbl', 'Udumd', 'LckGN', 'ALOrl', 'AmQOY', 'kabJb', 'ZYcQU', 'GumLl', 'kGamN', 'NAacQ', 'kbmZO', 'aOLZU', 'OYuvb', 'lYrua', 'Zvalv', 'Qclad', 'GNAca', 'adYrc', 'LvuOG', 'mZUrQ', 'cuOJb', 'mkmJN', 'YNrAm', 'GJGcZ', 'rbYbu', 'QbkAc', 'dvNvA', 'Juaml', 'rvOvU', 'kLvdN', 'NbmQU', 'rdLJa', 'OAmGr', 'advYO', 'vkYGl', 'uQkrd', 'mLdkZ', 'bNdmG', 'ObZbA', 'QOLmu', 'dmZvm', 'ZNLOv', 'AlQaQ', 'bYGOZ', 'vAuNl', 'LNUrJ', 'QLrOJ', 'ubALm', 'UaZma', 'kdaAJ', 'LcNUJ', 'ZdNmU', 'bdUNu', 'ckLAL', 'NvuGr', 'NbacA', 'YJLcA', 'aNYmb', 'rcmuv', 'vmuLl', 'ZkGmY', 'YLQmG', 'dGLAl', 'aLNlk', 'ObOQl', 'AZlLN', 'mUOcO', 'Ldrbv', 'damYb', 'AZaJc', 'LOLkU', 'ckduA', 'OQarQ', 'ZJLmr', 'rGUAY', 'GLluA', 'OdlNm', 'LAclA', 'JmvmO', 'JZOAk', 'JdOAY'];
      const L2affixes_list = ['TAm', 'YcM', 'tAY', 'OMC', 'DKP', 'mAM', 'DOk', 'mhc', 'YBO', 'ATc', 'PTl', 'Cdt', 'lRE', 'BCD', 'cDR', 'Akd', 'EcR', 'RDM', 'cPK', 'PMd', 'Tmc', 'tcB', 'ABb', 'OYK', 'Dmh', 'mCd', 'OBT', 'PED', 'dPc', 'OPE', 'TRK', 'tRb', 'dRA', 'YDE', 'bRC', 'Yht', 'OtM', 'APT', 'EAO', 'bTE', 'CEM', 'kBD', 'dBC', 'BbM', 'KmE', 'kPM', 'kKE', 'hBK', 'Tbk', 'MAB', 'TRkY', 'MCkm', 'AdYl', 'RCdc', 'CmYA', 'KlkD', 'dmRb', 'YKPB', 'dTAh', 'dEPD', 'KEdl', 'EKBO', 'EPBT', 'CPMl', 'YTOM', 'OdOP', 'KOYC', 'dCKc', 'RYlD', 'cthB', 'bAMO', 'BCAd', 'CMdP', 'APEM', 'AlKD', 'lMck', 'BYhT', 'RdCc', 'mtKP', 'cMRl', 'MKmY', 'khMD', 'YbBT', 'bdtK', 'TmTm', 'kDOm', 'kMEC', 'DlDT', 'CKOb', 'BRDh', 'PMYm', 'TPOM', 'DbMR', 'hRKm', 'DOAK', 'hEct', 'mKcD', 'PEdK', 'Ckbd', 'YDTk'];
      const L2stems_list = ['hbmA', 'bROC', 'OCmk', 'kKRC', 'KdAR', 'BbOD', 'DhCP', 'AdDb', 'TdTD', 'TdmA', 'EMYK', 'AbKD', 'RhPm', 'OdYP', 'DCmh', 'KElB', 'BPAl', 'hkRK', 'KDPA', 'TEBK', 'mARM', 'dKRD', 'AMkC', 'mdkK', 'tdDd', 'Ctmb', 'CYPc', 'DBkl', 'PYkC', 'tRdM', 'kPOt', 'hTDd', 'YObA', 'Ehbt', 'RCcE', 'ctkt', 'TklD', 'hChY', 'chAh', 'COTK', 'mBYl', 'lBlE', 'EhRm', 'TDKh', 'CmcO', 'TKDk', 'dYdA', 'tmYh', 'BEPO', 'OtlR', 'McMD', 'khmh', 'OEPk', 'lRCB', 'YmBd', 'ORbk', 'mBbK', 'OcYM', 'AlTd', 'DhMt', 'lTmO', 'EdBb', 'DlDd', 'ACcO', 'bAdk', 'RtRh', 'KMOc', 'DBlh', 'bcOR', 'MhKd', 'kcOY', 'blMk', 'MBmE', 'OMlT', 'mhtc', 'tmAK', 'MDKP', 'PlEK', 'kCRm', 'Ddck', 'tRPD', 'RKYk', 'hbkd', 'MTdY', 'PdDT', 'bcbM', 'PcBT', 'DMRP', 'TPCb', 'YlYc', 'Mlth', 'ktBd', 'PEtE', 'YKRk', 'hCkt', 'hlkT', 'lBKt', 'BECk', 'KABA', 'dRht', 'kKEdM', 'dClOC', 'DmAME', 'EltMB', 'KRARm', 'tKDmh', 'PCMPK', 'kcCRt', 'EPMDk', 'htmhC', 'KAERM', 'DOchl', 'EtMDM', 'DRPkY', 'BKDRY', 'EPERd', 'bmdAB', 'CDEmY', 'lhCTC', 'hYDmt', 'PMPtk', 'BOCRM', 'kcdOt', 'TObCO', 'OAmAd', 'lbBDE', 'hAROK', 'hlbtb', 'hmKPM', 'DcPTc', 'btlck', 'kDRKc', 'cdKBY', 'BMEMA', 'dTmED', 'TAdhM', 'KMDYt', 'ECtbD', 'KBKBE', 'bRABt', 'RkmdC', 'AYkEh', 'lAOKM', 'MkmEd', 'Blmcl', 'chEDO', 'dRbDb', 'kdEdY', 'PctRC', 'dMThk', 'BOckP', 'hTtBb', 'lKdbc', 'hlctE', 'ODBDA', 'COtBD', 'YlCPB', 'DkTCP', 'EYtYR', 'kRCkO', 'cBROB', 'dCtMA', 'thbOM', 'TbKME', 'ckdAm', 'OmtlD', 'cDOEB', 'KTDTB', 'CkBOP', 'RdPtD', 'PDPhl', 'dKDth', 'cRElD', 'lRckA', 'cROMt', 'PCPDh', 'BATOc', 'Phktk', 'PEkhA', 'dMYBP', 'Cchtd', 'DBPhc', 'tcYbd', 'MBKRE', 'BdtAC', 'hBmMC', 'RYtkc', 'DOBhY', 'RlAKc', 'mBmlA', 'kPkRA', 'tDPRk', 'dOYml', 'kMbTR', 'ABPRB', 'tmtEM', 'lCbcm', 'EMbDP', 'CRdBd', 'TCbDC'];
      return [L1affixes_list, L1stems_list, L2affixes_list, L2stems_list]
    };

    function cycle_through(L1affixes_list, L1stems_list, L2affixes_list, L2stems_list) {
      const testingaffix_indices = [0,1,2,3,4,1,2,3,4,0];
    
      function wordcycle(affixes,stems) {
        var reps = 0;
        var words_list = [];
        var listlength = words_list.length;
        while (listlength < 50) {
          var words_list = [];
          var congruenttesting_list = [];
          var words_dict = {};
          var congruenttesting_dict = {};
          var training_dict = {};
          var affix_subset = jsPsych.randomization.sampleWithoutReplacement(affixes, 5);
          var stem_subset = jsPsych.randomization.sampleWithoutReplacement(stems, 10);
          reps++; /* increase by 1 */ 
          console.log('Finished rep ' + reps + ' of generating word list.')
          for (let i = 0; i < stem_subset.length; i++) {
            var j = 0;
            while (j < affix_subset.length) {
              var stem = stem_subset[i];
              var last = stem.slice(-1); //
              var affix = affix_subset[j];
              if (stem != affix && last != affix[0]) {
                words_list.push([stem + affix]); /* append */ 
                var parts = [stem, affix];
                var word = stem + affix;
                var dictkeys = Object.keys(words_dict);
                if (dictkeys.includes(word) == false) {
                  words_dict[word] = parts
                };
              };
              j++;
            };
            var indice = testingaffix_indices[i];
            var affix = affix_subset[indice];
            var stem = stem_subset[i];
            var word = stem + affix;
            if (congruenttesting_list.includes(word) == false) {
              congruenttesting_list.push([stem + affix]);
              var parts = [stem, affix];
              var word = stem + affix;
              congruenttesting_dict[word] = parts
            };
          };
          var words_list = Object.keys(words_dict);
          var listlength = words_list.length;
          if (listlength < 50) {
            var affix_subset = [];
            var stem_subset = [];
            var words_list = [];
            var congruenttesting_list = [];
            var words_dict = {};
            var congruenttesting_dict = {};
            var training_dict = {}
          };
        };
        if (words_list.length == 50) {
          console.log('Finished testing word list.');
          congruenttesting_list2 = [...congruenttesting_list];
          var congruenttesting_list = [];
          var training_dict = Object.assign({}, words_dict);
          var training_list = Object.keys(training_dict);
          for (word of congruenttesting_list2) {
            var word = word.toString();
            congruenttesting_list.push(word)
          };
          for (let i = 0; i < congruenttesting_list.length; i++) {
            var word = congruenttesting_list[i];
            var training_list = Object.keys(training_dict);
            if (training_list.includes(word)) {
              delete training_dict[word];
            };
          };
          var training_list = Object.keys(training_dict);
        };
        return [affix_subset, stem_subset, words_dict, words_list, training_dict, training_list, congruenttesting_dict, congruenttesting_list]
      };

      function cross_language_testing(L1affixsubset_list, L1stemsubset_list, L2affixsubset_list, L2stemsubset_list) {
        const testingaffix_indices = [0,1,2,3,4,1,2,3,4,0];
        incongruenttesting_list = [];
        incongruenttesting_dict = {};
        for (let i = 0; i < L1stemsubset_list.length; i++) {
          var indice = testingaffix_indices[i];
          var affix = L1affixsubset_list[indice];
          var stem = L2stemsubset_list[i];
          var word = stem + affix;
          if (stem[-1] != affix[0] && incongruenttesting_list.includes(word) == false) {
            incongruenttesting_list.push([stem + affix]);
            var word = stem + affix;
            incongruenttesting_dict[word] = parts
          };
        };
        for (let j = 0; j < L2stemsubset_list.length; j++) {
          var indice = testingaffix_indices[j];
          var affix = L2affixsubset_list[indice];
          var stem = L1stemsubset_list[j];
          var word = stem + affix;
          if (stem[-1] != affix[0] && incongruenttesting_list.includes(word) == false) {
            incongruenttesting_list.push([stem + affix]);
            var parts = [stem, affix];
            var word = stem + affix;
            incongruenttesting_dict[word] = parts
          };
        };
        return [incongruenttesting_list, incongruenttesting_dict]
      };
    
      /* generate word lists for both languages */
      var incongruenttesting_list = [];
      while (incongruenttesting_list.length < 20) {
        var values = wordcycle(L1affixes_list, L1stems_list);
        var L1affixsubset_list = values[0];
        var L1stemsubset_list = values[1];
        var L1words_dict = values[2];
        var L1words_list = values[3];
        var L1training_dict = values[4];
        var L1training_list = values[5];
        var L1congruenttesting_dict = values[6];
        var L1congruenttesting_list = values[7];
        var values2 = wordcycle(L2affixes_list, L2stems_list);
        var L2affixsubset_list = values2[0];
        var L2stemsubset_list = values2[1];
        var L2words_dict = values2[2];
        var L2words_list = values2[3];
        var L2training_dict = values2[4];
        var L2training_list = values2[5];
        var L2congruenttesting_dict = values2[6];
        var L2congruenttesting_list = values2[7];
        var training_list = L1training_list.concat(L2training_list);
        var training_dict = Object.assign({},L1training_dict,L2training_dict);
        var congruenttesting_list = L1congruenttesting_list.concat(L2congruenttesting_list);
        var congruenttesting_dict = Object.assign({},L1congruenttesting_dict,L2congruenttesting_dict);
        var values3 = cross_language_testing(L1affixsubset_list, L1stemsubset_list, L2affixsubset_list, L2stemsubset_list);
        var incongruenttesting_list = values3[0];
        var incongruenttesting_dict = values3[1];
        for (let i = 0; i < incongruenttesting_list.length; i++) {
          var word = congruenttesting_list[i];
          var training_list = Object.keys(training_dict);
          if (training_list.includes(word)) {
            delete training_dict[word];
          };
        };
        var training_list = Object.keys(training_dict);
        
      };
      var all_morphemes = Object.values(training_dict);
      var all_morphemes = all_morphemes.flat();
      var all_morphemes = [...new Set(all_morphemes)];
      all_morphemes.sort((a, b) => a.length - b.length);
      var exp_threes = [];
      var exp_fours = [];
      var exp_fives = [];
      for (morpheme of all_morphemes) {
        if (morpheme.length == 3) {
          exp_threes.push(morpheme)
        };
        if (morpheme.length == 4) {
          exp_fours.push(morpheme)
        };
        if (morpheme.length == 5) {
          exp_fives.push(morpheme)
        };
      };
      var big_threes = [];
      var big_fours = [];
      var big_fives = [];
      for (morpheme of L1affixes_list) {
        if (morpheme.length == 3 && all_morphemes.includes(morpheme) == false) {
          big_threes.push(morpheme)
        };
        if (morpheme.length == 4 && all_morphemes.includes(morpheme) == false) {
          big_fours.push(morpheme)
        };
      };
      for (morpheme of L1stems_list) {
        if (morpheme.length == 4 && all_morphemes.includes(morpheme) == false) {
          big_fours.push(morpheme)
        };
        if (morpheme.length == 5 && all_morphemes.includes(morpheme) == false) {
          big_fives.push(morpheme)
        };
      };
      for (morpheme of L2affixes_list) {
        if (morpheme.length == 3 && all_morphemes.includes(morpheme) == false) {
          big_threes.push(morpheme)
        };
        if (morpheme.length == 4 && all_morphemes.includes(morpheme) == false) {
          big_fours.push(morpheme)
        };
      };
      for (morpheme of L2stems_list) {
        if (morpheme.length == 4 && all_morphemes.includes(morpheme) == false) {
          big_fours.push(morpheme)
        };
        if (morpheme.length == 5 && all_morphemes.includes(morpheme) == false) {
          big_fives.push(morpheme)
        };
      };
      var all_confounds = [];
      var confound_threes = [];
      var confound_fours = [];
      var confound_fives = [];
      confound_threes = jsPsych.randomization.sampleWithoutReplacement(big_threes, parseInt(exp_threes.length));
      confound_fours = jsPsych.randomization.sampleWithoutReplacement(big_fours, parseInt(exp_fours.length));
      confound_fives = jsPsych.randomization.sampleWithoutReplacement(big_fives, parseInt(exp_fives.length));
      var all_confounds = confound_threes.concat(confound_fours, confound_fives);
      if (all_confounds.length == all_morphemes.length && confound_threes.length == exp_threes.length && confound_fours.length == exp_fours.length && confound_fives.length == exp_fives.length) {
        console.log("Correctly generated familiarity confound set.")
      };
      var familiarity_pairs = [];
      for (let i = 0; i < 30; i++) {
        familiarity_pairs.push([all_morphemes[i], all_confounds[i]])
      };
      return [L1affixsubset_list, L1stemsubset_list, L2affixsubset_list, L2stemsubset_list, L1words_dict, L1words_list, L1training_dict, L1training_list, L1congruenttesting_dict, L1congruenttesting_list, L2words_dict, L2words_list, L2training_dict, L2training_list, L2congruenttesting_dict, L2congruenttesting_list, training_list, training_dict, congruenttesting_list, congruenttesting_dict, incongruenttesting_list, incongruenttesting_dict, familiarity_pairs]
    };

    var values4 = import_morphemes();
    var L1affixes_list = values4[0];
    var L1stems_list = values4[1];
    var L2affixes_list = values4[2];
    var L2stems_list = values4[3];
    var values5 = cycle_through(L1affixes_list, L1stems_list, L2affixes_list, L2stems_list);
    var L1affixsubset_list = values5[0];
    var L1stemsubset_list = values5[1];
    var L2affixsubset_list = values5[2];
    var L2stemsubset_list = values5[3];
    var L1words_dict = values5[4];
    var L1words_list = values5[5];
    var L1training_dict = values5[6];
    var L1training_list = values5[7];
    var L1congruenttesting_dict = values5[8];
    var L1congruenttesting_list = values5[9];
    var L2words_dict = values5[10];
    var L2words_list = values5[11];
    var L2training_dict = values5[12];
    var L2training_list = values5[13];
    var L2congruenttesting_dict = values5[14];
    var L2congruenttesting_list = values5[15];
    var training_list = values5[16];
    var training_dict = values5[17];
    var congruenttesting_list2 = values5[18];
    var congruenttesting_dict = values5[19];
    var incongruenttesting_list2 = values5[20];
    var incongruenttesting_dict = values5[21];
    var familiarity_pairs = values5[22];
    var incongruenttesting_list = [];
    for (word of incongruenttesting_list2) {
      var word = word.toString();
      incongruenttesting_list.push(word)
    };
    var congruenttesting_list = [];
    var congruenttesting = [];
    var incongruenttesting = [];
    for (word of congruenttesting_list2) {
      var word = word.toString();
      congruenttesting_list.push(word)
    };
    for (word of congruenttesting_list) {
      congruenttesting.push([word,0])
    };
    for (word of incongruenttesting_list) {
      incongruenttesting.push([word,1])
    };
    var testing = congruenttesting.concat(incongruenttesting);
    if (training_list.length == 80 && testing.length == 40) {
      console.log('Correctly generated complete stimuli set.')
    };

    console.log('Training list: ' + training_list);
    console.log(testing);

    /* JSPSYCH EXPERIMENT SCRIPT */ 
    var timeline = []; 

    var preload = {
      type: jsPsychPreload,
      images: ['esempio.png']
    };
    timeline.push(preload);

    document.body.style.backgroundColor = "#808080";

    function training_randomisation(training_list) {
      var listlength = training_list.length;
      var rand_lst = ['efjnpqsz'];
      var rep = 0;
      while (rand_lst.length < (listlength + 1)) {
        if (rep < 500) {
          var word = jsPsych.randomization.sampleWithoutReplacement(training_list, 1)[0];
          var last2_word = word.slice(-2);
          var last_training = rand_lst.slice(-1)[0];
          var last2_training = last_training.slice(-2);
          var first2_word = word.slice(0, 2);
          var first2_training = last_training.slice(0, 2);
          if (first2_word != first2_training && last2_word != last2_training && rand_lst.includes(word) == false) {
            rand_lst.push(word)
          };
          rep++;
        };
        if (rep >= 500) {
          var rand_lst = ['efjnpqsz'];
          var rep = 0
        }
      };
      rand_lst.shift();
      var rand_lst = rand_lst.flat();
      return rand_lst
    };
    
    function testing_randomisation(testing) {
      var listlength = testing.length;
      var rand_lst = [['efjnpqsz',0]];
      var rep = 0;
      while (rand_lst.length < (listlength+1)) {
        if (rep < 500) {
          var item = jsPsych.randomization.sampleWithoutReplacement(testing, 1)[0];
          var word = item[0];
          var word_condition = item[1];
          var last_item = rand_lst.slice(-1)[0];
          var last_word = last_item.slice(0)[0];
          var first2_word = word.slice(0, 2);
          var first2_last_word = last_word.slice(0, 2);
          var last2_word = word.slice(-2);
          var last2_last_word = last_word.slice(-2);
          if (first2_word != first2_last_word && last2_word != last2_last_word && rand_lst.includes(item) == false) {
            rand_lst.push(item)
          };
          rep++
        };
        if (rep >= 500) {
          var rand_lst = [['efjnpqsz',0]];
          var rep = 0;
        }
      };
      rand_lst.shift();
      return rand_lst
    };

    function FisherYatesShuffle(array) {
      var m = array.length, t, i;
      while (m) {
        i = Math.floor(Math.random() * m--);
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }
    return array;
    };

    var trainingn = 3;
    var rand_training1 = training_randomisation(training_list);
    var rand_training2 = training_randomisation(training_list);
    var rand_training3 = training_randomisation(training_list);
    var rand_testing = testing_randomisation(testing);
    var familiarity_pairs = FisherYatesShuffle(familiarity_pairs);

    /* Participant ID textbox */
    var sbjIDPrompt = {
      type: jsPsychSurveyHtmlForm,
      preamble: '<p>ID Partecipante:</b></p>',
      html: '<input name="ID" type="text" required/></p>',
      button_label: "Continuare"
    };

    var contButton = {
      type: jsPsychHtmlButtonResponse,
      stimulus: '',
      choices: ['Continue']
    };

    var instructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p style="font-size: 15px;">Prima di cominciare, le chiediamo di leggere il modulo di consenso informato e confermare la sua volontà di partecipare all'esperimento.</p><p style="font-size: 15px;"> La preghiamo di ricordare che questo è un progetto di ricerca e che la sua partecipazione è completamente volontaria. Lei si potra' ritirare in qualunque momento, senza necessariamente dover dare alcuna spiegazione. Lo studio al quale Le si chiede di partecipare ha lo scopo di esaminare come i lettori elaborno le parole scritte. La somministrazione delle prove è individuale. Lei sarà impegnato in una sessione di lavoro della durata media di 10 minuti, e un questionario di 10 minuti. L’ordine delle prove ed il loro svolgimento sono stabiliti in modo tale da evitare un eventuale affaticamento. Tutte le prove saranno precedute da un breve addestramento in modo tale che abbia la possibilità di familiarizzare con il compito. Sono previste alcune pause nel corso dello svolgimento dell’esperimento. Nonostante il testing preveda delle prove cognitive, il presente esperimento non costituisce una prova clinica che permetta la diagnosi di eventuali patologie.</p><p style="font-size: 15px;"> Tutti i dati raccolti grazie alla partecipazione Sua e di altre persone volontarie saranno custoditi in server sicuri e protetti da password, e non sarà consentito ad alcuna persona non autorizzata di accedervi. Le Sue informazioni personali saranno conservate separatamente dai risultati della presente ricerca, cui saranno associati soltanto attraverso un ID arbitrario. Grazie a questo processo di anonimizzazione dei dati, a nessun ricercatore sarà possibile analizzare i risultati sapendo da quale specifico partecipante essi provengono. Inoltre, questa procedura renderà impossibile la Sua identificazione anche nel momento in cui i risultati della ricerca fossero pubblicati su riviste scientifiche, o presentati a congressi o in qualsiasi altro pubblico consesso. Più in generale, i dati raccolti saranno trattati in accordo con le leggi sulla privacy e in conformità al Decreto Legislativo 30 giugno 2003 n. 196 “Codice in materia di protezione dei dati personali”.</p><p style="font-size: 15px;"> Prima di esprimere il suo consenso alla partecipazione, Le ricordiamo ancora che in caso Lei abbia bisogno di delucidazioni su qualunque aspetto della procedura sperimentale, il ricercatore è a Sua completa disposizione (aliebelt@sissa.it, davide.crepaldi@sissa.it).</p><p style="font-size: 15px;"> Le chiediamo di premere un tasto qualsiasi per continuare al consenso.</p>`,
    };

    var consent = {
      type: jsPsychSurveyMultiSelect,
      questions: [
        {
          prompt: "Dichiaro di esprimere il mio consenso a partecipare allo studio e dichiaro:", 
          options: ["di aver letto attentamente le spiegazioni relative a questo studio e all’intera procedura sperimentale;"],
          required: true
        },
        {
          prompt: "",
          options: ["di essere stato informata/o riguardo alle finalità e agli obiettivi della ricerca in questione;"],
          required: true
        },
        {
          prompt: "", 
          options: ["di aver avuto la possibilità di porre domande a proposito di qualsiasi aspetto della procedura sperimentale e di aver ottenuto risposte soddisfacenti;"],
          required: true
        },
        {
          prompt: "", 
          options: ["di essere a conoscenza dei disagi eventualmente causati dall’esperimento;"],
          required: true
        },
        {
          prompt: "", 
          options: ["di aver ricevuto soddisfacenti assicurazioni sulla riservatezza delle informazioni ottenute dall’esame della propria persona;"],
          required: true
        },
        {
          prompt: "", 
          options: ["di essere consapevole di potersi ritirare in qualsiasi fase dello studio."],
          required: true
        },
      ],
      button_label: "Continuare"
    };

    var welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p>Buenvenuto all'esperimento.</p><p> In questa prima parte, vedrai delle parole prese da una lingua inventata. Le parole saranno scrite in un alfabeto nuovo. Facciamo finta che questa lingua sia una lingua parlata dagli alieni.</p><p> Vorremmo chiederle di guardare queste parole aliene. Nella parte successiva, testeremo se ha prestato attenzione a queste parole.</p><p> Per favore, chiama lo sperimentatore se ha qualche domanda.</p><p> Premi un tasto qualsiasi per vedere un esempio.</p>`,
    };

    var example = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: "<p>Ecco un esempio di cosa vedrai durante questa parte dell'esperimento:</p><img src='esempio.png' height='400px'><p>Quando sei pronti per iniziare, premi un tasto qualsiasi.</p></div",
    };

    /* TRAINING */
    var stimulus_object1 = [];

    for (let i = 0; i < rand_training1.length; i++) {
      const temporal_object1 = {
        obj_type: 'text',
        content: rand_training1[i],
        font: "60px BACS",
        text_color: "white"
      };
      stimulus_object1.push(temporal_object1)
    };

    const viewing_time = 800;
    const isi = 200;

    const rsvp_trial1 = {
      type: jsPsychPsychophysics,
      stimuli: stimulus_object1,
      response_start_time: (viewing_time + isi) * rand_training1.length - isi,
      on_start: function(trial) {
        for (let i = 0; i < rand_training1.length; i++) {
          trial.stimuli[i].file = rand_training1[i]
          const start = (viewing_time + isi)  * i;
          trial.stimuli[i].show_start_time = start;
          trial.stimuli[i].show_end_time = start  + viewing_time 
        }
      }
    };
    timeline.push(rsvp_trial1);

    var inter_training1 = {
          type: jsPsychHtmlKeyboardResponse,
          stimulus: `<p>Hai completato la prima sezione di questa parte.</p><p> Premi un tasto qualsiasi per continuare.</p>`
        };
    timeline.push(inter_training1);
    
    var stimulus_object2 = [];

    for (let i = 0; i < rand_training2.length; i++) {
      const temporal_object2 = {
        obj_type: 'text',
        content: rand_training2[i],
        font: "60px BACS",
        text_color: "white"
      };
      stimulus_object2.push(temporal_object2)
    };

    const rsvp_trial2 = {
      type: jsPsychPsychophysics,
      stimuli: stimulus_object2,
      response_start_time: (viewing_time + isi) * rand_training2.length - isi,
      on_start: function(trial) {
        for (let i = 0; i < rand_training1.length; i++) {
          trial.stimuli[i].file = rand_training2[i]
          const start = (viewing_time + isi)  * i;
          trial.stimuli[i].show_start_time = start;
          trial.stimuli[i].show_end_time = start  + viewing_time 
        }
      }
    };

    const loop_node2 = {
      timeline: [rsvp_trial2],
      loop_function: function(data){
        if(jsPsych.pluginAPI.compareKeys(data.values()[0].response, ' ')){
          return true;
        } else {
          return false;
        }
      }
    };
    timeline.push(rsvp_trial2);

    var inter_training2 = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p>Hai completato la seconda sezione di questa parte.</p><p> Premi un tasto qualsiasi per continuare.</p>`
    };
    timeline.push(inter_training2);

    var stimulus_object3 = [];

    for (let i = 0; i < rand_training3.length; i++) {
      const temporal_object3 = {
        obj_type: 'text',
        content: rand_training3[i],
        font: "60px BACS",
        text_color: "white"
      };
      stimulus_object3.push(temporal_object3)
    };

    const rsvp_trial3 = {
      type: jsPsychPsychophysics,
      stimuli: stimulus_object3,
      response_start_time: (viewing_time + isi) * rand_training3.length - isi,
      on_start: function(trial) {
        for (let i = 0; i < rand_training3.length; i++) {
          trial.stimuli[i].file = rand_training1[i]
          const start = (viewing_time + isi)  * i;
          trial.stimuli[i].show_start_time = start;
          trial.stimuli[i].show_end_time = start  + viewing_time 
        }
      }
    };

    const loop_node3 = {
      timeline: [rsvp_trial3],
      loop_function: function(data){
        if(jsPsych.pluginAPI.compareKeys(data.values()[0].response, ' ')){
          return true;
        } else {
          return false;
        }
      }
    };
    timeline.push(rsvp_trial3);

    var post_training = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<p>Benissimo, hai completato la prima parte dell'esperimento.</p><p> Premi un tasto qualsiasi per continuare.</p>`
    };
    timeline.push(post_training);

    jsPsych.run(timeline);
  </script>
</html>
